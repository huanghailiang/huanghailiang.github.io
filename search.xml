<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python debug 调试工具：pdb]]></title>
    <url>%2F2019%2F09%2F30%2Fpython-debug-pdb%2F</url>
    <content type="text"><![CDATA[python debug 调试工具：pdb在使用命令行调试程序的时候，我们知道在C语言里面有一个工具叫gdb，可以帮助我们实现单步调试等操作，那么在python里面其实也有一个类似的工具pdb，这个工具可以帮助我们对python程序在命令行中进行单步调试等操作。 运行1python -m pdb ***.py pdb的常用命令说明：1234567891011l #查看运行到哪行代码 n #单步运行，跳过函数 s #单步运行，可进入函数 p 变量 #查看变量值 b 行号 #断点设置到第几行 b #显示所有断点列表 cl 断点号 #删除某个断点 cl #删除所有断点 c #跳到下一个断点 r #return当前函数 exit #退出]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 设置固定IP]]></title>
    <url>%2F2019%2F09%2F15%2Fubuntu-%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%2F</url>
    <content type="text"><![CDATA[Ubuntu 设置固定IP因为各种原因机房断电了，重启后服务器找不到了，后来确定是之前忘记设置固定IP了。 设置固定IP的方法方法一 （该方法针对18.04可行，以前的版本好像不太行，没有试过，不过下面两个方法针对所有版本）进入/etc/netplan/目录，会发现有一个yaml结尾的文件，我这里是50-cloud-init.yaml，可能每个人的不一样，但是没有关系，使用vim打开然后编辑，我的编辑结果如下 1234567891011121314151617# This file is generated from information provided by# the datasource. Changes to it will not persist across an instance.# To disable cloud-init's network configuration capabilities, write a file# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:# network: &#123;config: disabled&#125;network: ethernets: enp0s31f6: dhcp4: true enp4s0: #dhcp4: true dhcp4: no addresses: [172.16.8.227/24] gateway4: 172.16.8.1 nameservers: addresses: [172.16.8.1, 114.114.114.114] version: 2 最后执行以下命令更新IP1sudo netplan apply 方法二在路由器上设置IP与MAC绑定。 方法三参考以前的博客设置服务器网络———by邵碧尧]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py文件转换成exe格式]]></title>
    <url>%2F2019%2F09%2F09%2Fpy2exe%2F</url>
    <content type="text"><![CDATA[py文件转换成exe格式本人写好的py再给别人使用的时候，往往都需要再在别人的电脑上配置一遍环境，感觉超级麻烦，所以找到了pyinstaller这个工具，可以帮助我直接生成exe文件，当然也帮我做好了库环境的包含工作，简单方便，在此记录。 安装pyinstaller1pip install pyinstaller 打包程序在命令行中进入所需打包的目录； 打包指令： 1pyinstaller -F demo.py 参数含义：123456-F 指定打包后只生成一个exe格式的文件-D –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项）-c –console, –nowindowed 使用控制台，无界面(默认)-w –windowed, –noconsole 使用窗口，无控制台-p 添加搜索路径，让其找到对应的库。-i 改变生成程序的icon图标 注意 只能在windows上使用 只能使用英文路径]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh实现端口映射]]></title>
    <url>%2F2019%2F09%2F05%2Fssh%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[ssh实现端口映射 当一台服务器拥有公网IP，或者域名解析的时候（这个可以使用ddns进行配置），我们其他的服务器上面的服务也想映射出来，那么我们可以选择重新获取一个公网IP或者域名解析，但是这种方法会增加我们的消费，下面我们使用ssh来实现端口映射，从而实现其他服务器上的服务也能实现外网访问的操作。 ssh的端口转发命令：转发到远端：ssh -C -f -N -g -L 本地端口:目标IP:目标端口 用户名@目标IP 转发到本地：ssh -C -f -N -g –R 本地端口:目标IP:目标端口 用户名@目标IP 其中一些参数如下，想了解更多请查看帮助1234567891011-C，是进行数据压缩。-f，是后台认证用户/密码，通常和-N连用，不用登录到远程主机。只有当提示用户名密码的时候才转向前台。-N，是不执行远端命令，在只是端口转发时这条命令很有用处。-g ，在-L/-R/-D参数中，是允许远端主机连接本地转发端口，如果不加这个参数，只允许本地主机建立连接。-L，则是将本地端口映射到远端主机端口。本地端口:目标IP:目标端口-R，表明是将远端主机端口映射到本地端口。本地端口:目标IP:目标端口]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10远程链接共享文件夹存在问题]]></title>
    <url>%2F2019%2F09%2F04%2Fwin10%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[win10远程链接共享文件夹存在问题我们在服务器上打开了一个共享文件夹，但是在远程链接的时候会发现链接不上，这可能是自己本地电脑的配置没有打开。 解决方法 按win+r键盘组合键打开“运行” 在运行框中输入 “gpedit.msc ”，点击确定或者直接按键盘上的回车键。 组策略编辑器就打开了 依次选择 计算机配置 —&gt; 管理模板 —&gt; 网络 —&gt; Lanman工作站 然后右边 启用不安全的来宾登录 进去后选择 已启用 —&gt; 应用 即可]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改运行中的docker容器端口映射]]></title>
    <url>%2F2019%2F08%2F22%2Fdocker-p%2F</url>
    <content type="text"><![CDATA[修改运行中的docker容器端口映射 在docker run的时候我们可能会忘记设置端口映射，或者我们已经设置过端口映射，但是因为某种原因，我们需要更改端口号，这个时候我们就需要进行更改端口映射的操作。 但是一般情况下是不可以改变容器的端口映射的，只能通过run命令指定端口号。 网上有很多方法： 1、删除原容器，重新新建容器，这时候使用-p指令添加端口映射； 2、修改容器配置文件，然后重启docker服务； 修改配置文件 /var/lib/docker/containers/[hash_of_the_container_ID]/hostconfig.json 重启docker服务操作 systemctl restart docker 3、利用docker commit新构镜像【建议使用的方法】 停止docker容器 1docker stop container_name commit新构docker image 1docker commit container_name new_image:tag 使用上一步生成的image重新生成一个新的镜像（此时记得加上端口映射） 1docker run --name new_container_name -p 80:80 new_image:tag 注意： 对于第1个方法虽然很快捷，但是我们可能会需要重新配置镜像文件，比较麻烦； 对于第2个方法，我这边尝试好像是有问题的，我虽然改过了配置文件，但是重启docker以后端口的配置文件又自动变回去了，这一点我很郁闷，我也不知道为啥会这样，这里没有深究，先这样吧。 对于第3个方法，我觉得需要注意的是就是docker images界面多了一个镜像文件，可能管理啥的比较乱，但是省去了配置新镜像的繁琐步骤，不过我们需要知道原镜像的启动方式，以及本地文件的挂载等，我这边有些服务是通过自动文件脚本安装的，这个时候有时候找不到启动方式，或者对docker不太熟悉不知道本地文件怎么挂载上去，或者不知道本地文件的位置在哪里等等各种原因，这种方法虽然可以运行，但是可能还是不会达到想要的效果，所以我们还是需要知道原docker的启动方式以及本地文件地址等，再进行操作。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地部署ShowDoc]]></title>
    <url>%2F2019%2F08%2F19%2FShowDoc%2F</url>
    <content type="text"><![CDATA[本地部署ShowDocShowDoc介绍ShowDoc就是一个非常适合IT团队的在线文档分享工具，它可以加快团队之间沟通的效率。 使用markdown编辑的，语法简单好用，使用后感觉非常好使，所以在此留下链接地址，留做记录防止以后还会需要。当然本地没有服务器，我们也可以使用在线的ShowDoc。 ShowDoc安装开源GitHub地址 中文教程 感觉作者的中文教程写的很清楚了，安装十分方便，可以使用自动脚本安装，也可以使用手动安装。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用grep在文件夹查找文本内容]]></title>
    <url>%2F2019%2F08%2F19%2Fuse-grep-to-find-something%2F</url>
    <content type="text"><![CDATA[使用grep在文件夹查找文本内容1grep -r "要查找的内容" 目录名 参数： -r ( 或者 --recursive ) 选项用于遍历 /path的所有子目录，而 -l ( 或者 --files-with-matches ) 选项用于只打印匹配文件的文件名，而不是匹配的行( 这也可以提高速度，因为 grep 停止了在第一个 MATCH 中读取该选项的文件)。 -H 导致打印文件名( 在搜索多个文件时隐含) -r 执行递归搜索 -n 导致打印行号 -I 忽略二进制文件( 补码： -a 将所有文件视为文本 -F 将 search term 视为文本，而不是正则表达式 -I 执行不区分大小写的搜索 --color=always 在管道经过 less 时强制颜色。 要使 less 支持颜色，你需要使用 -r 选项 其他操作可以查看帮助 grep --help]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Docker部署ShareLaTex并简单配置中文环境]]></title>
    <url>%2F2019%2F07%2F25%2FDocker-deployment-ShareLaTex%2F</url>
    <content type="text"><![CDATA[使用Docker部署ShareLaTex并简单配置中文环境转载：使用Docker部署ShareLaTex并简单配置中文环境来自 YXN’s Blog 因为工作需要，在服务器上配置了ShareLaTex环境，因为资料真的超级少，然后看到了转载博主的博客较为详细，故转载在此，但是博主博客中有一点点地方没有说到后面会进行补充。 准备工作系统与Docker环境安装同上篇Docker部署GitLab并实现基本配置，然后继续按照教程安装==docker-compose==组件。 安装并配置ShareLaTeX 由于ShareLaTeX的安装依赖于MongoDB和Redis，因此本文将使用官方向导建议使用==docker-compose==快速部署ShareLaTeX 拉取最新的ShareLaTeX镜像 1docker pull sharelatex/sharelatex 下载==docker-compose.yml==文件，并进行配置，见Quick Start Guide 1234mkdir -p ~/sharelatex # 在用户目录下创建一个sharelatex文件夹cd ~/sharelatex # 进入sharelatex文件夹curl -O https://raw.githubusercontent.com/sharelatex/sharelatex/master/docker-compose.yml # 下载官方的docker-compose.yml配置文件sudo vi docker-compose.yml # 使用vi修改配置文件 需要配置的项 123456789101112131415161718192021222324252627# 避免端口重复ports: - 5000:80# 修改本地挂载目录volumes: - /home/docker/sharelatex:/var/lib/sharelatex# 添加升级texlive需要的环境变量，主要是添加2018目录到2017前面，目的是为了防止后面安装完整版texlive时出现错误# 【这里原博主有写，但是我添加以后好像并没有什么效果，不添加也是可以的】environment: - PATH: /usr/localsbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/texlive/2018/bin/x86_64-linux:/usr/local/texlive/2017/bin/x86_64-linux # 下面选项设置ShareLaTeX的显示样式SHARELATEX_APP_NAME: Our ShareLaTeXSHARELATEX_NAV_TITLE: Our ShareLaTeX InstanceSHARELATEX_HEADER_IMAGE_URL: http://somewhere.com/mylogo.pngSHARELATEX_LEFT_FOOTER: &apos;[&#123;&quot;text&quot;: &quot;Powered by &lt;a href=\&quot;https://www.sharelatex.com\&quot;&gt;ShareLaTeX&lt;/a&gt; 2016&quot;&#125;,&#123;&quot;text&quot;: &quot;Another page I want to link to can be found &lt;a href=\&quot;here\&quot;&gt;here&lt;/a&gt;&quot;&#125; ]&apos;SHARELATEX_RIGHT_FOOTER: &apos;[&#123;&quot;text&quot;: &quot;Hello I am on the Right&quot;&#125; ]&apos;# 修改mongo和redis的本地挂载目录# mongovolumes: - /home/docker/mongo_data:/data/db# redisvolumes: - /home/docker/redis_data:/data 创建并运行ShareLaTeX容器，启动后不要着急进入网站 12# 在sharelatex目录下docker-compose up -d ==这里有一点需要注意==：就是我们配置好ShareLaTex后，如何也配置好了后面的中文环境，如果这个时候我们再去更改配置文件==docker-compose.yml==的话，我们再重新==docker-compose up -d==更新docker环境参数的话，下面的所有的操作都将要重新执行，包括升级并安装texlive操作，以及中文环境的配置。 升级并安装完整版texlive，官方教程 12345678910111213141516171819202122232425262728# 进入容器的命令行（sharelatex容器本质上是一个Ubuntu）docker exec -it sharelatex bash# 进入texlive默认安装目录cd /usr/local/texlive# 复制2017文件夹为2018cp -a 2017 2018# 下载并运行升级脚本wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.shsh update-tlmgr-latest.sh -- --upgrade# 更换texlive的下载源，例如国内的清华源tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/# 升级tlmgrtlmgr update --self --all# 更新字体缓存（好像没成功，但是不影响下面操作）luaotfload-tool -fu# 安装完整版texlive（漫长的等待，不要让shell断开）tlmgr install scheme-full# 推出sharelatex的命令行界面，并重启sharelatex容器exitdocker restart sharelatex 使用ShareLaTeX 进入浏览器访问==http://192.168.8.21:5000/launchpad==，根据提示创建Admin用户。 配置中文写作环境 下载的sharelatex镜像里面默认是没有安装xfont和中文字体的，因此无法渲染中文文档，必须安装所需的中文字体，这里以Windows下常用字体和Adobe Song Std为例。原教程见ArchLinux 部署ShareLaTex并且配置中文支持。 将Windows字体库（即目录==C:\windows\fonts==）上传到host机，如果Windows安装了Git可以使用==scp==命令直接上传 在host机下把==fonts==目录打包并传到sharelatex容器中 12345678910111213# 进入fonts目录cd fonts/# 删除其中的.fon字体文件（该种格式文件在后面建立字体目录时会报错），只保留TrueType和OpenType字体，即.ttf和.otf# 一般地，如果只需要其中特定的中文字体，只需要上传需要的字体即可rm -r *.fon# 返回上层目录并打包cd ..tar -zcvf winfonts.tar.gz fonts/# 把压缩文件传到sharelatex容器的root目录下docker cp winfonts.tar.gz sharelatex:/root 在容器中安装Windows字体 12345678910111213141516171819# 进入容器的命令行界面$ docker exec -it sharelatex bash# 通过安装wqy字体同时安装xfont工具$ apt-get install xfonts-wqy# 进入root目录，解压winfonts.tar.gz，并剪切到系统字体目录下cd ~tar -zxvf winfonts.tar.gzmv winfonts /usr/share/fonts/# 进入字体目录安装字体cd /usr/share/fonts/winfontsmkfontscalemkfontdirfc-cache -fv# 检查确认中文字体安装成功fc-list :lang=zh-cn 回到ShareLaTeX网站，创建一个新项目，使用CTEX宏集和XeLaTeX编译器，即可生成中文pdf。（详见CTEX宏集手册） 因为学校论文的需要，有时需要其他中文字体，例如Adobe宋体，其安装流程与上述基本一致。（PS：在GitHub上可以找到公开的Adobe Song Std字体，涉及版权这里不放链接） ==注意==：到此出配置完成了，但是我们会发现我们直接写中文是有问题的，解决方案如下 （1）包含头 \documentclass[utf8]{ctexart} （2）点开左上角的Menu，进去将Compiler改成XeLaTex即可 这个时候我们就可以愉快的时使用ShareLatex的中文了 Latex教程和模板这一块暂时懒得写，就简单的收集整理了一下别人写好的，收集的链接再这里。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维导图 XMind 8 Update 7的激活教程]]></title>
    <url>%2F2019%2F07%2F25%2FXMind-8-Update-7%2F</url>
    <content type="text"><![CDATA[思维导图 XMind 8 Update 7的激活教程转自：xmind8 破解激活教程因为需要工作需要，需要经常用到思维导图来捋顺思路，然后发现了XMind这个软件比较不错，但是这个软件的pro版本有很多功能，但是需要序列号才可以使用pro，但是总会找到破解方法，破解后做一个备份，一遍后续有需要的时候使用。 安装XMind去XMind官网下载XMind进行安装，或者直接搜索下载即可。 下载破解补丁这里直接使用转载博主的链接（感谢原博主）： 下载地址： 链接：https://pan.baidu.com/s/1rgupjT51K0UeWgWTe3vGiQ 提取码：u11r 激活XMind 找到 XMind 安装目录, 如: D:\Program Files\XMind，将下载的破解补丁复制到这个目录中。 以文本格式打开安装目录中 XMind.ini 在 XMind.ini 最后追加一个字段-javaagent，然后加上XMindCrack.jar的绝对路径(PS 路径中不要有中文，否则会报错)。例如: 1-javaagent:D:\Program Files\XMind\XMindCrack.jar 打开 XMind, 点击帮助——序列号，然后输入以下序列号 ，邮箱随便填，可以填自己的。 1XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345 完成以上操作即可激活成功，可以使用pro功能了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex 模板和教程]]></title>
    <url>%2F2019%2F07%2F14%2Flatex%2F</url>
    <content type="text"><![CDATA[Latex 模板和教程overleaf templatesThe best source of free quality LaTeX templates！ 在简书中使用Latex书写数学公式 LaTex 入门 LaTeX零基础入门教程 【LaTeX Tips】LaTeX 模板收集 在线Latex公式编辑器 LaTeX常用操作：添加标题、作者、时间、摘要、标题、段落、目录、字体、引用、脚注、图片\表格插入、数学符号、公式、交叉引用等 在线进行表格转Latex工具Tables Generator 在线LateX公式编辑器在线latex公式编辑器]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献管理]]></title>
    <url>%2F2019%2F03%2F15%2F%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一、文献管理软件Zotero和Mendeley都是文献管理工具。网上对他们有一个对比Zotero, Mendeley, Papers比较 1、Zotero 使用教程Zotero官网地址zotero是开源的文献管理工具，可以方便的收集，组织，引用，和共享文献的工具。 1.1、安装及配置（安装了ZotFile和Zotero Scholar Citations插件） ZotFile：可以自动获取导入文件的元数据，自动命名附件 Zotero Scholar Citations：引用次数更新插件，不过这个插件需要翻出去才能使用。 1.2、数据备份这里使用了坚果云，其实就是一个跨平台的同步工具。 当然除了坚果云，我们还有很多的同步软件，比如Dropbox、OneDrive、Google Drive，不过在国内我们应该大部分都只能用oneDrive，所以这里介绍一下oneDrive同步【参考地址：Zotero使用第三方云服务同步（Dropbox、OneDrive、Google Drive）】: Step 1:任务栏—编辑—首选项—高级—数据存储位置—打开数据文件夹。 可以打开Zotero的数据文件夹。默认是用户文件夹下的Zotero文件夹。在其中可以看到有一个名为storage的文件夹，即为文件（pdf之类的）的存储位置。 Step 2:将storage文件夹剪切到，onedrive（或者其他）的同步位置。然后执行命令：1mklink /d &quot;C:\xxx\Zotero\storage&quot; &quot;D:\OneDrive\ZoteroData\storage&quot; 其中xxx为Zotero的地址。 Step 3:注册或者登陆Zotero用户。取消首选项中的文件同步。然后开始同步即可。 注： 1、安装好以后word中会有一个Zotero工具栏 2、浏览器插件Chrome好像需要翻墙，所以可以使用Firefox浏览器，只需要去Zotero官网下载插件,然后在Firefox浏览器中选择插件从文件安装附加组件，选中下载的插件安装重启浏览器既可。重启后右上角会有Save to Zotero图标。 2、Mendeley2.1、文献管理软件Mendeley优缺点分析2.2、用Mendeley在Word插入参考文献二、文件可视化分析软件CiteSpace和vosviewer工具都是用来对文献进行可视化分析的软件，首先都是去先去web of science上下载数据，然后导入到软件中进行一系列的可视化分析。 1、CiteSpace使用教程CiteSpace是一款可视化文献分析软件。 1.1、CiteSpace图文教程1.2、信息计量学|CiteSpace使用教程1.3、citespace介绍及使用2、Vosviewer使用教程Vosviewer一款文献可视化工具，是一款应用于科学文献中识别并显示科学发展新趋势和新动态的软件。 利用Citespace寻找某一学科领域的研究进展和当前的研究前沿，及其对应的知识基础。 2.1、VOSviewer中文视频教程2.2、如何快速梳理领域文献2.3、如何用VOSviewer分析CNKI数据]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Nibabel库进行nii图像的读写操作]]></title>
    <url>%2F2019%2F01%2F24%2FNibabel%2F</url>
    <content type="text"><![CDATA[因为后期主要的研究方向是医学图像处理，而现有手头的大部分数据都是nii格式或者是hdr，img格式的数据，所以首先第一步我们需要解决图像的读写问题。 其实使用OpenCV也可以方便的进行图像读取，但是这里暂时只学习Nibabel这个库，后面有时间的话再研究OpenCV在python中的使用。 Nibabel的安装可以通过pip进行安装1pip install nibabel 简单的图像读取和存储操作12345678910111213141516import osimport nibabel as nib# 读取图像path='C:\Users\Darren\Desktop\example.nii.gz'img=nib.load(path)# 查看图像的长宽高img.shap# 图像进行仿射变换img.affine.shap# 保存图像path_save='C:\Users\Darren\Desktop\example_save.nii.gz'img.to_filename(path_save)或者nib.save(img,path_save)]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow和pytorch环境搭建]]></title>
    <url>%2F2019%2F01%2F23%2Ftensorflow-and-pytorch-environment%2F</url>
    <content type="text"><![CDATA[tensorflow和pytorch环境搭建初入深度学习的坑，先从环境配置开始。 本文将记录在Ubuntu 18.04环境中的搭建，对于Windows环境的搭建，这里暂时不做叙述。 本文首先搭建一些基本环境，比如CUDA，CUDNN，opencv以及anaconda用于管理环境。 在安装的tf以及pytorch的时候我们可以使用国内的镜像安装12一次性的-i https://pypi.tuna.tsinghua.edu.cn/simple 也可以参考下面链接的方法进行设置： https://www.cnblogs.com/microman/p/6107879.htmlhttps://blog.csdn.net/qq_29007291/article/details/81103603 CUDA的安装因为之前已经写过教程，这里不在赘述，详见CUDA安装。 不过CUDA有时候安装不了，很有可能是gcc和g++版本的问题，所以安装不顺的时候，可以检查一下gcc和g++的版本是否过高或者过低。 CUDNN的安装去官网下载CUDNN的包，例如我这里下载的是cudnn-10.0-linux-x64-v7.4.2.24.tgz 执行一下操作进行解压安装12345tar -zxvf cudnn-10.0-linux-x64-v7.4.2.24.tgz sudo cp cuda/include/cudnn.h /usr/local/cuda/include/sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/sudo chmod a+r /usr/local/cuda/include/cudnn.h sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 可以通过一下指令查看CUDNN的版本信息1cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 OpenCV的安装1234567891011121314151617181920# 下载opencvgit clone https://github.com/opencv/opencv# 安装依赖项sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev libdc1394-22-dev # 处理图像所需的包sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-devsudo apt-get install libxvidcore-dev libx264-dev # 处理视频所需的包sudo apt-get install libatlas-base-dev gfortran # 优化opencv功能sudo apt-get install ffmpeg# 编译安装opencvcd opencvmkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..make sudo make install#配置环境sudo /bin/bash -c &apos;echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/opencv.conf&apos;sudo ldconfig 安装python-opencv可直接使用apt安装12sudo apt-get install python-opencvsudo apt-get install python-numpy 可以直接使用pip进行安装1pip install opencv-python Anaconda的安装去官网下载相应的Anaconda安装包，例如我这里下载的是Anaconda3-2018.12-Linux-x86_64.sh 执行以下命令安装1bash Anaconda3-2018.12-Linux-x86_64.sh 根据提示一路yes即可，最后那个VS code也可以不安装，根据需要自行选择。 如果之前没有配置环境变量导致conda不可用，可以按照以下方式解决1234# 将anaconda的bin目录加入PATH，根据版本不同，也可能是~/anaconda3/binecho &apos;export PATH=&quot;~/anaconda2/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc# 更新bashrc以立即生效source ~/.bashrc 安装完成后可以通过以下方式查看版本1conda --version 注：对于服务器上多人使用，我们可以将anaconda安装在/opt目录下，激活使用的时候我们使用 source /etc/profile 指令 tensorflow和Pytorch环境的配置为了方便环境的版本的管理，我们使用anaconda来创建环境，然后来配置深度学习的环境，这样不至于让自己的环境很乱，只是每次进入环境的时候需要手动激活以下环境即可。 tensorflow的环境配置首先我们需要创建环境,这里我们创建一个名为tensorflow36的环境，其中python版本为3.61conda create -n tensorflow36 python=3.6 其次我们激活环境1source activate tensorflow36 安装tensorflow123456# CPU版本pip install tensorflow# GPU版本pip install tensorflow-gpu# 卸载用pip uninstall tensorflow 到此tensorflow的环境就安装好了，此处如果CUDA的版本过高的话GPU版本装上了也是用不了的，故需要注意版本问题。 退出当前环境1source deactivate tensorflow36 pytorch的环境配置首先我们创建一个名为pytorch的环境，其中python版本为3.71conda create -n pytorch python=3.7 其次我们激活环境1source activate pytorch pytorch的安装可以参考Pytorch官网进行安装。官网提供了多种安装方式，需要注意自己环境中的python版本以及CUDA的版本。到此pytorch的环境配置以及完成 退出当前环境1source deactivate pytorch anaconda的简单使用创建环境1conda create --name &lt;env_name&gt; &lt;package_names&gt; 激活环境1source activate &lt;env_name&gt; 退出当前环境1source deactivate 显示已经创建的环境12345conda env list或conda info --envs或conda info -e 复制环境1conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt; 删除环境1conda remove --name &lt;env_name&gt; --all 获取当前环境中已安装的包信息1conda list 查找可供安装的包版本1234# 精确查找conda search --full-name &lt;package_full_name&gt;# 模糊查找conda search &lt;text&gt; 安装包123456# 在指定环境中安装包conda install --name &lt;env_name&gt; &lt;package_name&gt;# 在当前环境中安装包conda install &lt;package_name&gt;# 使用pip安装包pip install &lt;package_name&gt; 卸载包1234# 卸载指定环境中的包conda remove --name &lt;env_name&gt; &lt;package_name&gt;# 卸载当前环境中的包conda remove &lt;package_name&gt; 更新包12345678# 更新所有包conda update --all或conda upgrade --all# 更新指定包conda update &lt;package_name&gt;或conda upgrade &lt;package_name&gt;]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3 - NEURAL NETWORKS【神经网络】]]></title>
    <url>%2F2018%2F10%2F28%2Fpytorch-3%2F</url>
    <content type="text"><![CDATA[原文地址：https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html NEURAL NETWORKS 【神经网络】可以使用torch.nn包来构建神经网络。 现在您已经了解了autograd, nn依赖autograd来定义模型并区分它们。一个nn.Module包含层，和一种方法forward(input)，它返回output。 例如，对数字图像的分类网络： 卷积神经网络 它是一个简单的前馈网络。它获取输入，一个接一个地通过几个层，最后给出输出结果。 神经网络的典型训练过程如下： 定义具有一些可学习参数（或权重）的神经网络 迭代输入数据 通过网络处理输入 计算损失（输出与正确结果的距离） 将梯度传播回网络参数中 更新网络中的权重，使用简单的典型的更新规则：weight = weight - learning_rate * gradient 定义网络让我们定义这个网络： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import torchimport torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module): def __init__(self): #nn.Module子类的函数必须再构造函数种执行父类的构造函数 #下式等价于nn.Module.__init__(self) super(Net, self).__init__() # 1 input image channel, 6 output channels, 5x5 square convolution # kernel #卷积层'1'表示输入图片为单通道，‘6’表示输出通道数 #‘5’表示卷积核为5*5 self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) # an affine operation: y = Wx + b #仿射层/全连接层，y=Wx+b self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): #卷积 --&gt; 激活 --&gt; 池化 # Max pooling over a (2, 2) window x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) # If the size is a square you can only specify a single number x = F.max_pool2d(F.relu(self.conv2(x)), 2) #reshape, '-1'表示自适应 x = x.view(-1, self.num_flat_features(x)) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x def num_flat_features(self, x): size = x.size()[1:] # all dimensions except the batch dimension num_features = 1 for s in size: num_features *= s return num_featuresnet = Net()print(net) 输出： 1234567Net( (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=400, out_features=120, bias=True) (fc2): Linear(in_features=120, out_features=84, bias=True) (fc3): Linear(in_features=84, out_features=10, bias=True)) 你仅仅只需要定义forward函数，并且使用autograd会自动帮你定义backward函数（计算梯度的地方）。你可以在forward函数中使用任何Tensor操作。 模型的可学习参数由net.parameters()返回 1234params = list(net.parameters())print(len(params))print(params[0].size()) # conv1's .weight 输出 1210torch.Size([6, 1, 5, 5]) 让我们尝试一个随机的32x32输入注意:这个网络(LeNet)的预期输入大小是32x32。要在MNIST数据集中使用这个网络，请将数据集中的图像调整到32x32。 123input = torch.randn(1, 1, 32, 32)out = net(input)print(out) 输出 12tensor([[ 0.0435, -0.1141, -0.0298, -0.0904, 0.1214, 0.1464, -0.0767, 0.0372, 0.0243, -0.1016]], grad_fn=&lt;ThAddmmBackward&gt;) 使用随机梯度将所有参数和反向传播的梯度缓冲区归零： 12net.zero_grad()out.backward(torch.randn(1, 10)) 注： torch.nn只支持小批量。整个torch.nn包只支持小批量的样本输入，而不是一个单一的样本。 例如：nn.Conv2d将使用4D的tensor nSamples x nChannels x Height x Width. 如果你只有一个单一样本，只需要使用input.unsqueeze(0)去添加一个假的批处理维度。 在继续之前，让我们回顾一下到目前为止您所看到的所有类。 概要： torch.tensor 支持例如backward()的autograd操作的多维数组。也保留了tensor的梯度。 nn.Module 神经网络模型。使用帮助成像将它们移动到GPU,输出，加载等，方便的封装参数。 nn.Parameter Tensor的一种，当分配一个属性给Module的时候，会自动注册一个参数。 autograd.Function 实现autograd操作的前向和后向定义。每一个Tensor操作，至少创建一个Function节点，该节点连接到一个创建的Tensor并且对它的历史编码。 在这点上，我们覆盖包含了： 定义了神经网络 处理输入并且向后调用 还剩下： 计算损失 更新神经网络的权重 损失函数损失函数使用一对输入（输出，目标），并且计算一个值来估计输出到目标的距离。 在nn包下有几种不同的损失函数。一个简单的损失是：nn.MSELoss它计算输入和目标之间的均方误差。 例如：1234567output = net(input)target = torch.randn(10) # a dummy target, for exampletarget = target.view(1, -1) # make it the same shape as outputcriterion = nn.MSELoss()loss = criterion(output, target)print(loss) 输出：1tensor(1.1380, grad_fn=&lt;MseLossBackward&gt;) 现在，如果您按照loss向后方向，使用其 .grad_fn属性，您将看到如下所示的计算图： 1234input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear -&gt; MSELoss -&gt; loss 因此，当我们调用时loss.backward()，整个图形会随着损失而区分，并且图形中的所有张量都requires_grad=True 将.grad使用渐变累积其Tensor。 为了说明，让我们向后退几步： 123print(loss.grad_fn) # MSELossprint(loss.grad_fn.next_functions[0][0]) # Linearprint(loss.grad_fn.next_functions[0][0].next_functions[0][0]) # ReLU 输出：123&lt;MseLossBackward object at 0x00000225B8275CF8&gt;&lt;ThAddmmBackward object at 0x00000225B8275DA0&gt;&lt;ExpandBackward object at 0x00000225B8275CF8&gt; BACKPROP 【反向传播】要反向传播错误，我们所要做的就是loss.backward()。您需要清除现有渐变，否则渐变将累积到现有渐变。 现在我们就调用loss.backward()，看一下conv1在向后之前和之后的偏差梯度。 123456789net.zero_grad() # zeroes the gradient buffers of all parametersprint('conv1.bias.grad before backward')print(net.conv1.bias.grad)loss.backward()print('conv1.bias.grad after backward')print(net.conv1.bias.grad) 输出： 1234conv1.bias.grad before backwardtensor([0., 0., 0., 0., 0., 0.])conv1.bias.grad after backwardtensor([ 0.0056, 0.0107, -0.0053, -0.0074, 0.0051, -0.0064]) 现在，我们已经看到了如何使用损失函数。 唯一要学习的是： 更新网络权重 更新权重实践中使用的最简单的更新规则是随机梯度下降（SGD）： weight = weight - learning_rate * gradient 我们可以使用简单的python代码实现它： 123learning_rate = 0.01for f in net.parameters(): f.data.sub_(f.grad.data * learning_rate) 但是，当您使用神经网络时，您希望使用各种不同的更新规则，例如SGD，Nesterov-SGD，Adam，RMSProp等。为了实现这一点，我们构建了一个小包：torch.optim它实现了所有这些方法。使用它非常简单： 1234567891011import torch.optim as optim# create your optimizeroptimizer = optim.SGD(net.parameters(), lr=0.01)# in your training loop:optimizer.zero_grad() # zero the gradient buffersoutput = net(input)loss = criterion(output, target)loss.backward()optimizer.step() # Does the update 注意：观察如何使用optimizer.zero_grad()手动将梯度缓冲区设置为零。这是因为梯度是按照Backprop部分解释的那样积累的。]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言解析txt中的参数]]></title>
    <url>%2F2018%2F10%2F25%2FParse-Param%2F</url>
    <content type="text"><![CDATA[C语言解析txt中的参数// ParseParam.h — See ParseParam.c for example of use//http://www.gdargaud.net/Hack/SourceCode.html H文件1234567891011121314151617181920212223242526272829303132333435363738// ParseParam.h -- See ParseParam.c for example of use//http://www.gdargaud.net/Hack/SourceCode.html#ifndef _PARSE_PARAM#define _PARSE_PARAM#include &lt;stdlib.h&gt;#include "ctype.h"extern char* ReadParseParam(const char* FileName, char *VariableName);extern char *TempPP;int SeperateIntegerFromArray(char *Array, int *List);int SeperateFloatFromArray(char *Array, float *List);int SeperateStringFromArray(char *Array, char **List);#define ParseParamString(FileName, Str) \ if ((TempPP=ReadParseParam((ParamFileName), #Str))!=NULL) \ strcpy(Str, TempPP); else Str[0]='\0' #define ParseParamInt(FileName, Int) \ if ((TempPP=ReadParseParam((ParamFileName), #Int))!=NULL) \ Int=atoi(TempPP); else Int=0#define ParseParamHex(FileName, Int) \ if ((TempPP=ReadParseParam((ParamFileName), #Int))!=NULL) \ Int=strtol(TempPP, NULL, 16); else Int=0#define ParseParamFloat(FileName, Flt) \ if ((TempPP=ReadParseParam((ParamFileName), #Flt))!=NULL) \ Flt=atof(TempPP); else Flt=0#define ParseParamBool(FileName, B) \ if ((TempPP=ReadParseParam((ParamFileName), #B))!=NULL) \ B=(toupper(TempPP[0])=='Y' || toupper(TempPP[0])=='T'|| TempPP[0]=='1'); else B=0#endif CPP文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191/******************************************************************************MODULE: ParseParamPURPOSE: Parses a parameter file into variablesEXAMPLE:ParseParamString("Param.txt", DirSfcBin);ParseParamInt("Param.txt", MaxLat);ParseParamFloat("Param.txt", MaxScale);ParseParamBool("Param.txt", DoLegend);ParseParamHex("Param.txt", ColorZero);ParseParamHex("Param.txt", ColorNan);ParseParamHex("Param.txt", ColorCurve);will parse the following file:-------- Start of file "Param.txt"; This is the parameter file for RainMerge.exe and MergeMonth.exe; Comments are preceded by ; # or !; You can use blank lines tooDirSfcBin="/raid/data/SfcRain/" ; Use double quotes around stringsNAN=-9999. ; float, ignored valueMaxLat = 40 ; integerColorZero= 0xC0C0C0 ; hex valueColorNan = FFFFFF ; optional 0xColorCuve= 0x101040 ; Syntax errorMaxScale=10. ; leading/trailing spaces are ignoredDoLegend=Y ; Bool can be T, F, Y, N, True, False, Yes, No, 0, 1...------- End of file "Param.txt"******************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include "ParseParam.h"#define LINE_DIM 8192char *TempPP=NULL;/******************************************************************************FUNCTION: ReadParamPURPOSE: Read one parameter by parsing a parameter fileRETURNS: a pointer to a string containing the value or NULL if not foundUse the macros to convert to typed values******************************************************************************/char* ReadParseParam(const char* FileName, char *VariableName) &#123; static char Str[LINE_DIM]; char *VarName, *Comment=NULL, *Equal=NULL; char *FirstQuote, *LastQuote, *P1, *P2; int Line=0, Len=0, Pos=0; FILE *file=fopen(FileName, "r"); if (file==NULL) &#123; fprintf(stderr, "\nError: Could not find file %s", FileName); exit(1); &#125; while (fgets(Str, LINE_DIM-1, file) != NULL) &#123; Line++; Len=strlen(Str); if (Len==0) goto Next; if (Str[Len-1]=='\n' || Str[Len-1]=='\r') Str[--Len]='\0'; Equal = strchr (Str, '='); // search for equal sign Pos = strcspn (Str, ";#!"); // search for comment Comment = (Pos==Len) ? NULL : Str+Pos; if (Equal==NULL || ( Comment!=NULL &amp;&amp; Comment&lt;=Equal)) goto Next; // Only comment *Equal++ = '\0'; if (Comment!=NULL) *Comment='\0'; // String FirstQuote=strchr (Equal, '"'); // search for double quote char LastQuote=strrchr (Equal, '"'); if (FirstQuote!=NULL) &#123; if (LastQuote==NULL) &#123; fprintf(stderr, "\nError reading parameter file %s line %d - Missing end quote.", FileName, Line); goto Next; &#125; *FirstQuote=*LastQuote='\0'; Equal=FirstQuote+1; &#125; // removes leading/trailing spaces Pos=strspn (Str, " \t"); if (Pos==strlen(Str)) &#123; fprintf(stderr, "\nError reading parameter file %s line %d - Missing variable name.", FileName, Line); goto Next; // No function name &#125; while ((P1=strrchr(Str, ' '))!=NULL || (P2=strrchr(Str, '\t'))!=NULL) if (P1!=NULL) *P1='\0'; else if (P2!=NULL) *P2='\0'; VarName=Str+Pos; //while (strspn(VarName, " \t")==strlen(VarName)) VarName++; Pos=strspn (Equal, " \t"); if (Pos==strlen(Equal)) &#123; fprintf(stderr, "\nError reading parameter file %s line %d - Missing value.", FileName, Line); goto Next; // No function name &#125; Equal+=Pos; // printf("%s=%s\n", VarName, Equal); if (strcmp(VarName, VariableName)==0) &#123; // Found it fclose(file); return Equal; &#125;Next:; &#125; // not found fprintf(stderr, "Error reading parameter file %s - Variable %s not found.", FileName, VariableName); fclose(file); return NULL;&#125;int SeperateIntegerFromArray(char *Array, int *List)&#123; //input: the array of integer with ',' as the seperater //output: the number of segments and the array of parsed integers int count; char *pch, *pre_start; char item[1024]; pch = strchr(Array, ','); count = 0; pre_start = Array; while (pch!=NULL) &#123; int length = pch-pre_start; strncpy(item, pre_start, length); item[length] = '\0'; pre_start = pre_start + length + 1; List[count] = atoi(item); count++; pch = strchr(pre_start, ','); &#125; sprintf(item, "%s", pre_start); List[count] = atoi(item); count++; return count;&#125;int SeperateFloatFromArray(char *Array, float *List)&#123; //input: the array of integer with ',' as the seperater //output: the number of segments and the array of parsed integers int count; char *pch, *pre_start; char item[1024]; pch = strchr(Array, ','); count = 0; pre_start = Array; while (pch!=NULL) &#123; int length = pch-pre_start; strncpy(item, pre_start, length); item[length] = '\0'; pre_start = pre_start + length + 1; List[count] = atof(item); count++; pch = strchr(pre_start, ','); &#125; sprintf(item, "%s", pre_start); List[count] = atof(item); count++; return count;&#125;int SeperateStringFromArray(char *Array, char **List)&#123; //input: the array of integer with ',' as the seperater //output: the number of segments and the array of parsed integers int count; char *pch, *pre_start; pch = strchr(Array, ','); count = 0; pre_start = Array; while (pch!=NULL) &#123; int length = pch-pre_start; strncpy(List[count], pre_start, length); List[count][length] = '\0'; pre_start = pre_start + length + 1; count++; pch = strchr(pre_start, ','); &#125; sprintf(List[count], "%s", pre_start); count++; return count;&#125; 使用方法（例子）123456 char ParamFileName[300];sprintf(ParamFileName, "%s", argv[1]); //ParamFileName=argv[1]="parfile.txt"ParseParamInt(ParamFileName, Image_X_Size);ParseParamInt(ParamFileName, Image_Y_Size);ParseParamInt(ParamFileName, Image_Z_Size);ParseParamString(ParamFileName, AtlasFiles);]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2 - Autograd：自动微分]]></title>
    <url>%2F2018%2F09%2F29%2Fpytorch-2%2F</url>
    <content type="text"><![CDATA[原文地址：https://pytorch.org/tutorials/beginner/blitz/autograd_tutorial.html Autograd: automatic differentiation 【Autograd：自动微分】在PyTorch的所有神经网络的核心是autograd包。让我们首先简要地访问它，然后我们去训练我们地第一个神经网络。 autograd包未Tensor上地所有操作提供了自动微分。它是一个自由定义地框架，这意味着你的 BP算法是由你代码地运行方式定义地，并且每次迭代都是不同的。 让我们用更简单的术语来看看这些例子。 Tensortorch.Tensor 是这个包的核心类。如果你设置它的属性 .requires_grad为True，则它会开始跟踪上面的所有操作。当你完成你的计算你可以调用 .backward()并且自动计算出所有梯度。tensor的梯度将会累积到 .grad属性中。 要停止tensor的跟踪历史，你可以调用 .detach()将其域计算历史记录分离，并且防止未来的计算被跟踪。 未来防止跟踪历史记录（和使用内存），你可以使用torch.no_grad():将代码块包装起来，在评估模型时这可能会非常有用，因为模型可能具有 reguires_grad=True的训练参数，但是我们不需要梯度。 还有一个类对于autograd实现非常重要- a Function. Tensor和Function是互相连通的，并且构建了一个非循环图，它编码了一个完整的计算历史。每个tensor都有一个 .grad_fn属性，该属性引用function已创建的Tensor(除了用户所创建的Tensor-他们的grad_fn属性是None)。 如果你想计算导数，你可以在Tensor中调用 .backward()。如果Tensor是一个标量（也就是说它包含一个元素数据），则不需要指定任何参数 backward(),但是如果它有更多的元素，你需要指定一个和tensor匹配形状的梯度参数。 1import torch 创建一个tensor并且设置requires_grad=true跟踪它的计算 12x = torch.ones(2, 2, requires_grad=True)print(x) 输出12tensor([[1., 1.], [1., 1.]], requires_grad=True) 做一个tensor操作：12y = x + 2print(y) 输出12tensor([[3., 3.], [3., 3.]], grad_fn=&lt;AddBackward&gt;) y是作为一个操作的结果创建的，所以它有一个grad_fn。 1print(y.grad_fn) 输出1&lt;AddBackward object at 0x00000251A7EC7F60&gt; 在y上做更多的操作 1234z = y * y * 3out = z.mean()print(z, out) 输出12tensor([[27., 27.], [27., 27.]], grad_fn=&lt;MulBackward&gt;) tensor(27., grad_fn=&lt;MeanBackward1&gt;) .requires_grad_(…)改变一个现有Tensor的requiresgrad标志。如果没有给出输入标志，则默认为False。1234567a = torch.randn(2, 2)a = ((a * 3) / (a - 1))print(a.requires_grad)a.requires_grad_(True)print(a.requires_grad)b = (a * a).sum()print(b.grad_fn) 输出123FalseTrue&lt;SumBackward0 object at 0x00000251A7ED09B0&gt; Gradients 【梯度】现在让我们后退一步，因为out包含一个标量，out.backward（）等价于out.backward（torch.tensor(1)）。 1out.backward() 输出梯度d（out）/ dx 1print(x.grad) 输出12tensor([[4.5000, 4.5000], [4.5000, 4.5000]]) 你应该有一个矩阵4.5. 我们称 outTensor “o”. 我们有 $o = \frac{1}{4}\sum_i z_i$,$z_i = 3(x_i+2)^2$ and $z_i\bigr\rvert_{x_i=1} = 27$.因此,$\frac{\partial o}{\partial x_i} = \frac{3}{2}(x_i+2)$, 因此$\frac{\partial o}{\partial x_i}\bigr\rvert_{x_i=1} = \frac{9}{2} = 4.5$. 你可以用autograd做很多疯狂的事情！ 1234567x = torch.randn(3, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000: y = y * 2print(y) 输出 1tensor([-816.7130, 1152.6641, 765.0383], grad_fn=&lt;MulBackward&gt;) 1234gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)y.backward(gradients)print(x.grad) 输出 1tensor([ 102.4000, 1024.0000, 0.1024]) 我们可以阻止autograd跟踪历史在Tensor上使用 .requires_grad=True 使用torch.no_grad()将代码块封装起来。 12345print(x.requires_grad)print((x ** 2).requires_grad)with torch.no_grad(): print((x ** 2).requires_grad) 输出123TrueTrueFalse Read Later: Documentation of autograd and Function is at http://pytorch.org/docs/autograd]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch study]]></title>
    <url>%2F2018%2F09%2F25%2FPytorch-study%2F</url>
    <content type="text"><![CDATA[说明本人根据官网教程翻译整理，供自己学习、查阅，后续翻译也将是以下网址; pytorch官网 翻译的教程网址 官网翻译教程1、tensor tutorial (tensor教程) 2、Autograd: automatic differentiation 【Autograd：自动微分】 3、NEURAL NETWORKS【神经网络】]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA study]]></title>
    <url>%2F2018%2F09%2F25%2FCUDA-study%2F</url>
    <content type="text"><![CDATA[说明CUDA学习的自我整理。 自己学习的笔记1、CUDA学习笔记（一）之CUDA安装及GPU硬件介绍 2、CUDA学习笔记（二）之调试工具:cuda-gdb 3、CUDA学习笔记（三）之第一个CUDA程序及计时]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[排序算法总结参考：https://blog.csdn.net/c406495762/article/details/78979946 文章根据网上博客还有百度百科等总结了一下8中排序方法（并且使用C语言进行了实现）： 1、冒泡排序 2、直接插入排序 3、希尔排序 4、快速排序 5、简单选择排序 6、堆排序 7、归并排序 8、基数排序 算法分析]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1 - tensor_tutorial (tensor教程)]]></title>
    <url>%2F2018%2F09%2F25%2Fpytorch-1%2F</url>
    <content type="text"><![CDATA[原文地址：https://pytorch.org/tutorials/beginner/blitz/tensor_tutorial.html What is PyTorch这是一个基于Python的科学计算包，目标是两组优势： NumPy的替代品，可以使用GPU的强大功能 深入学习研究平台，提供最大的灵活性和速度 Getting Started Tensor Tensor与NumPy的多维数组相似，添加的是Tensor也可以用于GPU加速计算。 12from __future__ import print_functionimport torch 构建一个未初始化的5*3的矩阵：12x = torch.empty(5, 3)print(x) 输出：12345tensor([[0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000]]) 创建一个随机初始化矩阵 12x = torch.rand(5, 3)print(x) 输出：12345tensor([[0.2799, 0.2665, 0.5734], [0.7835, 0.6617, 0.8958], [0.9766, 0.6714, 0.2334], [0.6510, 0.0141, 0.6451], [0.6124, 0.3446, 0.6923]]) 创建一个全零矩阵并且类型为long:12x = torch.zeros(5, 3, dtype=torch.long)print(x) 输出：12345tensor([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]) 根据数据直接创建一个tensor12x = torch.tensor([5.5, 3])print(x) 输出：1tensor([5.5000, 3.0000]) 或者根据现有tensor创建一个tensor。这些方法将重用输入tensor的属性，如dtype，除非用户提供新的值 12345x = x.new_ones(5, 3, dtype=torch.double) # new_* methods 获得大小print(x)x = torch.randn_like(x, dtype=torch.float) # 重新赋予类型print(x) # 结果拥有相同的大小 输出：12345678910tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64)tensor([[ 0.3567, -1.2192, -1.5638], [-0.9681, 0.5553, 0.1525], [ 0.6320, -0.5874, 0.6034], [-0.5114, -0.6262, -0.0601], [-0.0572, 0.9120, 0.9557]]) 获取它的大小：1print(x.size()) 输出：1torch.Size([5, 3]) 注意： “torch.Size”实际上是一个元组，所以它支持所有的元组操作。 有多个语法操作。在下面的例子中，我们将看一看加法操作。 语法1 12y = torch.rand(5, 3)print(x + y) 输出：12345tensor([[ 0.5408, -0.8138, -1.3310], [-0.0024, 0.6934, 0.3962], [ 1.2138, -0.5800, 1.2939], [ 0.1962, -0.5142, 0.7489], [ 0.6374, 1.1835, 1.3452]]) 语法2 1print(torch.add(x, y)) 输出： 12345tensor([[ 0.5408, -0.8138, -1.3310], [-0.0024, 0.6934, 0.3962], [ 1.2138, -0.5800, 1.2939], [ 0.1962, -0.5142, 0.7489], [ 0.6374, 1.1835, 1.3452]]) 作为参数提供一个输出tensor 123result = torch.empty(5, 3)torch.add(x, y, out=result)print(result) 输出：12345tensor([[ 0.5408, -0.8138, -1.3310], [-0.0024, 0.6934, 0.3962], [ 1.2138, -0.5800, 1.2939], [ 0.1962, -0.5142, 0.7489], [ 0.6374, 1.1835, 1.3452]]) 在原位置上操作 123# adds x to yy.add_(x)print(y) 输出：12345tensor([[ 0.5408, -0.8138, -1.3310], [-0.0024, 0.6934, 0.3962], [ 1.2138, -0.5800, 1.2939], [ 0.1962, -0.5142, 0.7489], [ 0.6374, 1.1835, 1.3452]]) 注意： 任何对一个tensor进行变异的操作都是用_。例如:“x.copy_(y)’ ‘,’ ‘ x.t_()’ ‘,将改变“x”。 You can use standard NumPy-like indexing with all bells and whistles! 1print(x[:, 1]) 输出：1tensor([-1.2192, 0.5553, -0.5874, -0.6262, 0.9120]) 调整大小：如果你想要调整/重塑张量，你可以使用 torch.view: 1234x = torch.randn(4, 4)y = x.view(16)z = x.view(-1, 8) # the size -1 is inferred from other dimensionsprint(x.size(), y.size(), z.size()) 输出：1torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8]) 如果你有一个元素tensor，使用.item（）来获得作为Python的数值 123x = torch.randn(1)print(x)print(x.item()) 输出：12tensor([0.6536])0.653590977191925 Read later: 100+ Tensor operations, including transposing, indexing, slicing, mathematical operations, linear algebra, random numbers, etc., are described here http://pytorch.org/docs/torch_. NumPy Bridge将一个Torch Tensor转换成一个NumPy数组，反之亦然。 Torch Tensor和NumPy数组将共享它们的底层内存位置，而改变一个则会改变另一个。 将一个Torch Tensor转换为Numpy数组：12a = torch.ones(5)print(a) 输出：1tensor([1., 1., 1., 1., 1.]) 12b = a.numpy()print(b) 输出：1[1. 1. 1. 1. 1.] 看看numpy数组是如何在值中改变的。123a.add_(1)print(a)print(b) 输出：12tensor([2., 2., 2., 2., 2.])[2. 2. 2. 2. 2.] 将一个Numpy数组转换为Torch Tensor,看看如何改变np数组自动改变了Torch Tensor 123456import numpy as npa = np.ones(5)b = torch.from_numpy(a)np.add(a, 1, out=a)print(a)print(b) 输出：12[2. 2. 2. 2. 2.]tensor([2., 2., 2., 2., 2.], dtype=torch.float64) CPU上所有的Tensors，除了CharTensor 都支持跟NumPy之间的相互转换。 CUDA TensorsTensor可以使用.to方法移动到任何设备上。 123456789# let us run this cell only if CUDA is available# We will use ``torch.device`` objects to move tensors in and out of GPUif torch.cuda.is_available(): device = torch.device(&quot;cuda&quot;) # a CUDA device object y = torch.ones_like(x, device=device) # directly create a tensor on GPU x = x.to(device) # or just use strings ``.to(&quot;cuda&quot;)`` z = x + y print(z) print(z.to(&quot;cpu&quot;, torch.double)) # ``.to`` can also change dtype together! 输出：12tensor([1.6536], device=&apos;cuda:0&apos;)tensor([1.6536], dtype=torch.float64)]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA学习笔记（三）之第一个CUDA程序及计时]]></title>
    <url>%2F2018%2F07%2F02%2F3-cuda-first-program%2F</url>
    <content type="text"><![CDATA[第一个CUDA程序我们将使用矢量求和的简单运算来学习一下CUDA的简单编程。 矢量求和运算假设我们有两组数据，我们需要将这两组数据中对应的元素两两相加，并将结果保存在第三个数组中。 基于CPU的矢量求和CPU中矢量求和的函数：1234567void add_CPU(int *a, int *b, int *c)&#123; for (int i = 0; i &lt; N; i++) &#123; c[i] = a[i] + b[i]; &#125;&#125; 上面是CPU中的一个矢量求和的函数，采用了for循环来依次执行1234c[0]=a[0]+b[0];c[1]=a[1]+b[1];...c[N-1]=a[N-1]+b[N-1]; 我们可以发现每次循环的操作，只是内存地址不一样，但是指令都是一样的，所以可以看作他们每次循环都是一个独立的运算，那么我们将其并行起来是不是更好呢？假设我们有两个CPU计算核心，那么我们希望两个核心同时开始进行计算，那么我们的循环次数也将减半，运行时间将会变少。 对于上诉的问题，在CPU编程中我们也有并行编程的库可以来运行，比如Openmp这个并行工具就可以很好的实现这种操作，不过这将限制与我们计算机的CPU核心数目，我们也知道CPU的核心数目目前是非常有限的，所以对于大程序我们也是无能为力的，这个时候GPU的优势就体现出来了，对于上面每个循环互相独立，操作相同的计算，我们可以在GPU中开出足够多的线程来进行操作，这将大大降低计算时间。 基于GPU的矢量求和12345678__global__ void add(int *a, int *b, int *c)&#123; int tid = blockIdx.x*blockDim.x+threadIdx.x;//计算该索引处的数据 if (tid &lt; N) &#123; c[tid] = a[tid] + b[tid]; &#125;&#125; 上面是GPU中的一个矢量求和函数。 其中global是一个函数声明，说明这个函数是一个全局的函数，在设备上执行的。因为GPU是通过开启大量的线程来并行操作的，所以我们需要计算每个线程的编号，及就是上面程序中的tid.然后我们每个线程在根据这个线程好去读取每个线程需要用到的内存，再去完成计算。该程序的tid计算可以在下面完整的代码看出来因为我们可能不只开了一个块所以我们需要将块也考虑进来。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/*矢量求和运算a[i]+b[i]=c[i];*///CUDA的头文件#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;//C语言的头文件#include &quot;stdio.h&quot;#include &quot;time.h&quot;//宏定义 N为数组的长度 thread_num表示每个块中的线程数#define N 60000#define thread_num 1024//GPU函数申明__global__ void add(int *a, int *b, int *c);//CPU函数申明void add_CPU(int *a, int *b, int *c);int main()&#123; //GPU方法计时申明 float time_CPU, time_GPU; cudaEvent_t start_GPU, stop_GPU, start_CPU, stop_CPU; //CPU方法计时申明 float time_cpu, time_gpu; clock_t start_cpu, stop_cpu, start_gpu, stop_gpu; int a[N], b[N], c[N],c_CPU[N]; int *dev_a, *dev_b, *dev_c; //知道了每个块中所开的线程数量，那么我们就要知道我们需要开启多少个块 int block_num; //线程块中的数量需要向上取整，下面两个操作有可以/*********/ //block_num = (N % thread_num == 0) ? (N / thread_num) : (N / thread_num + 1); block_num = (N + thread_num - 1) / thread_num; //在GPU上分配内存 cudaMalloc((void**)&amp;dev_a, N*sizeof(int)); cudaMalloc((void**)&amp;dev_b, N*sizeof(int)); cudaMalloc((void**)&amp;dev_c, N*sizeof(int)); //在CPU上为a和b进行赋值操作 for (int i = 0; i &lt; N; i++) &#123; a[i] = -i; b[i] = i*i; &#125; //创建Event cudaEventCreate(&amp;start_CPU); cudaEventCreate(&amp;stop_CPU); //记录当前时间 cudaEventRecord(start_CPU, 0); start_cpu = clock(); //CPU计算/*******************************************************/ add_CPU(a, b, c_CPU); stop_cpu = clock(); //记录当前时间 cudaEventRecord(stop_CPU, 0); cudaEventSynchronize(start_CPU); //等待事件完成。 cudaEventSynchronize(stop_CPU); //等待事件完成。记录之前的任务 cudaEventElapsedTime(&amp;time_CPU, start_CPU, stop_CPU); //计算时间差 printf(&quot;The time for CPU:\t%f(ms)\n&quot;, time_CPU); cudaEventDestroy(start_CPU); //消除Event cudaEventDestroy(stop_CPU); //输出CPU结果 printf(&quot;\nResult from CPU:\n&quot;); for (int i = 0; i &lt; N; i++) &#123; printf(&quot;CPU:\t%d+%d=%d\n&quot;,a[i],b[i],c_CPU[i]); &#125; //GPU计算/*******************************************************/ //内存拷贝CPU-TO-GPU cudaMemcpy(dev_a, a, N*sizeof(int), cudaMemcpyHostToDevice); cudaMemcpy(dev_b, b, N*sizeof(int), cudaMemcpyHostToDevice); //创建Event cudaEventCreate(&amp;start_GPU); cudaEventCreate(&amp;stop_GPU); //记录当前时间 cudaEventRecord(start_GPU, 0); start_gpu = clock(); //调用cuda的核函数 //printf(&quot;block_num=%d\tthread_num=%d\n&quot;, block_num, thread_num); add &lt;&lt; &lt;block_num, thread_num &gt;&gt; &gt;(dev_a, dev_b, dev_c); stop_gpu = clock(); //记录当前时间 cudaEventRecord(stop_GPU, 0); cudaEventSynchronize(start_GPU); //等待事件完成。 cudaEventSynchronize(stop_GPU); //等待事件完成。记录之前的任务 cudaEventElapsedTime(&amp;time_GPU, start_GPU, stop_GPU); //计算时间差 printf(&quot;\nThe time for GPU:\t%f(ms)\n&quot;, time_GPU); //将GPU中的结果拷贝出来 cudaMemcpy(c, dev_c, N*sizeof(int), cudaMemcpyDeviceToHost); //输出GPU结果 printf(&quot;\nResult from GPU:\n&quot;); for (int i = 0; i &lt; N; i++) &#123; printf(&quot;GPU:\t%d+%d=%d\n&quot;,a[i],b[i],c[i]); &#125; cudaEventDestroy(start_GPU); //消除Event cudaEventDestroy(stop_GPU); //释放GPU上的内存 cudaFree(dev_a); cudaFree(dev_b); cudaFree(dev_c); printf(&quot;\nThe time for CPU by event:\t%f(ms)\n&quot;, time_CPU); printf(&quot;The time for GPU by event:\t%f(ms)\n&quot;, time_GPU); time_cpu = (float)(stop_cpu - start_cpu) / CLOCKS_PER_SEC; time_gpu = (float)(stop_gpu - start_gpu) / CLOCKS_PER_SEC; printf(&quot;\nThe time for CPU by host:\t%f(ms)\n&quot;, time_cpu); printf(&quot;The time for GPU by host:\t%f(ms)\n&quot;, time_gpu); return 0;&#125;//GPU函数__global__ void add(int *a, int *b, int *c)&#123; int tid = blockIdx.x*blockDim.x+threadIdx.x;//计算该索引处的数据 if (tid &lt; N) &#123; c[tid] = a[tid] + b[tid]; &#125;&#125;//CPU函数void add_CPU(int *a, int *b, int *c)&#123; for (int i = 0; i &lt; N; i++) &#123; c[i] = a[i] + b[i]; &#125;&#125; 完整代码的注解该代码中我使用了两种计时方式使用主机计时和使用时GPU计时。 使用主机计时123456789101112131415#include “time.h”... float time; clock_t start, stop; ... start=clock(); ...//需要计时的那一部分 stop=clock(); time=(float)(stop-start)/CLOCKS_PER_SEC; printf("The time by host:\t%f(ms)\n", time); 使用GPU计时123456789101112131415161718192021float time;cudaEvent_t start, stop;...//创建EventcudaEventCreate(&amp;start);cudaEventCreate(&amp;stop);//记录当前时间cudaEventRecord(start, 0);...//需要计时的那一部分//记录当前时间cudaEventRecord(stop, 0);cudaEventSynchronize(start); //等待事件完成。cudaEventSynchronize(stop); //等待事件完成。记录之前的任务cudaEventElapsedTime(&amp;time, start, stop); //计算时间差printf("The time by event:\t%f(ms)\n", time);cudaEventDestroy(start); //消除EventcudaEventDestroy(stop); CUDA程序编写流程通过上面一个简单的小程序，我们应该也可以体会到一个基本的CUDA程序编写的一个流程： 1、从CPU拷贝内存到GPU中； 2、调用GPU核函数进行并行计算； 3、从GPU拷贝计算结果的内存到CPU中。 注： 在2步调用GPU核函数的时候我们需要，分配一下我们需要多少个线程块参与计算，并且每个线程块中需要有多少个线程。这些跟硬件有一定的关系，同时一个好的线程规划可能会优化你的程序，这部分因为我也是小白，所以暂时也没有什么特别多的经验，按照之前的经验，只觉得每个线程块开的线程数应该是16或者32的倍数，这个应该跟warp中包含32个线程（目前我用的GPU是这样的）有关。目前大部分的GPU已经支持每个线程块有1024个线程，当然以前比较老的GPU有些只支持到512，所以这些我们需要自己注意一下。]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA学习笔记（二）之调试工具:cuda-gdb]]></title>
    <url>%2F2018%2F07%2F02%2F2-CUDA-gdb%2F</url>
    <content type="text"><![CDATA[一、Linux下命令行操作使用cuda-gdb对CUDA程序进行编译 1、编译程序编译程序的时候我们使用nvcc编译器，将其编译成可调式版本；-g 表示将CPU代码(host)编译成可调式版本，-G表示将GPU代码(kernel)编译成可调式版本。 例子：1nvcc -g -G XXX.cu -o XXX 2、进入调试器1cuda-gdb 进入调试器后可以使用3中的指令进行执行可执行文件，然后进行调试，也可以在cuda-gdb指令后面直接加上需要调试的可执行文件进行调试。 3、调试的基本指令 指令 简写 指令说明 举例 file exe_name 置顶可调试的可执行文件 file program set args arg1 arg2 … 设置命令行参数 set args 1 2 breakpoint b 设置断点，使代码在指定位置暂停执行。其参数可以是方法名，也可以是行号 b main; b 数字 run r 在调试器中执行程序 start 开始执行程序，并在main的第一行停住 next n 单步执行到下一行 continue c 继续执行已暂停的程序至下一个断点或程序结尾处 step s 单步执行，会进入函数内部执行 continue c 执行已暂停程序到下一断点或结尾处 print p 打印参数信息,查看变量 p var1 thread 列出当前主机线程 cuda 列出当前活跃的kernel/grid/block/thread内容，并允许将焦点移至此处 cuda thread(1, 1, 1); cuda kernel 1 block(1, 2, 1) cuda thread 列出当前活跃的GPU线程（若有的话） cuda kernel 列出当前活跃的GPU Kernel，并允许将“焦点”转移到指定的GPU线程 info 查看参数所包含的具体信息 info devices; info kernels; info threads backtrace bt 显示当前函数调用栈的内容 quit q 退出cuda-gdb 二、Linux下使用图形界面当我们装好了CUDA的时候，其实在图形界面下已经装好了一个叫“nsight”的编译器，我们可以直接用终端打开这个编译器，然后写好程序直接编译然后debug就可以了。 参考https://blog.csdn.net/sinat_28750977/article/details/69062708http://book.51cto.com/art/201301/376309.htm]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA学习笔记（一）之CUDA安装及GPU硬件介绍]]></title>
    <url>%2F2018%2F06%2F30%2F1-CUDA%2F</url>
    <content type="text"><![CDATA[一、CUDA安装与环境配置 Linux环境下的CUDA的安装因为之前的博客中有涉及到这一部分所以这里就不在详述。ubuntu16.04 Server install CUDA 不过我们在linux下使用GPU编程的时候有时候会遇到nvidia驱动挂掉的情况，这个时候我们需要修复它，在之前的博客中我们使用dkms来进行管理的方法。nvidia驱动挂掉 在linux下面我们经常会使用nvidia-smi指令对GPU的使用情况进行监测，但是有时候GPU监测时会不准确或者有时候程序退出了但是现存还被占用着，这种情况之前的博客也有解决方法。GPU监测时问题解决 Windows环境下的CUDA安装Windows环境下的安装，我们需要先安装Visual Studio编译器用于后面的编程使用，然后去nvidia的官网查找适用与该版本的Visual Studio的CUDA版本，剩下就比较简单了，直接开始安装，安装软件会自动帮你配置好环境变量等，安装好就可以直接使用了。可以去安装的VS中直接建立CUDA的工程进行编程使用了。 二、GPU硬件掌握部门的硬件知识，可以有助于我们更好的编写CUDA程序，可以更好的优化CUDA程序的性能。 首先我们需要先知道一些基本的一些专业名词： 英文 中文 Stream Processor（SP） 流处理器 Stream MultiProcessor（SM） 流处理器组 Thread 线程 Block 线程块 Grid 线程网格 Warp 线程束 shared memory 共享内存 kernel function 核函数 SP（Stream Processor）和SM（Stream MultiProcessor）是硬件层面的，Thread、Block、grid和warp是软件层面上的。 SP（streaming processor）：最基本的处理单元，也称为CUDA core。最后具体的指令和任务都是在SP上处理的。GPU进行并行计算，也就是很多个SP同时做处理。 SM（Stream MultiProcessor）：多个SP加上其他的一些资源组成一个SM。也叫GPU大核，其他资源如：warp scheduler，register，shared memory等。SM可以看做GPU的心脏（对比CPU核心），register和shared memory是SM的稀缺资源。CUDA将这些资源分配给所有驻留在SM中的threads。因此，这些有限的资源就使每个SM中active warps有非常严格的限制，也就限制了并行能力。 thread：一个CUDA的并行程序会被以许多个threads来执行。 block：数个threads会被群组成一个block，同一个block中的threads可以同步，也可以通过shared memory通信。 grid：多个blocks则会再构成grid。 warp：GPU执行程序时的调度单位，目前cuda的warp的大小为32，同在一个warp的线程，以不同数据资源执行相同的指令,这就是所谓 SIMT。 注对于硬件结构的图网上有很多，还有CUDA的指导手册中也有很多，这里为了简单就先不列出来了，如果未来有时间有兴趣，将会进一步进行优化。也可以去参看后面第四部分中的参考中的网址进行参考。 三、使用代码获取GPU的参数信息因为我们对于不用的GPU型号，其构架等信息都不一样，如果我们要想优化一个更好的CUDA程序，我们就需要更好的了解我们的硬件信息，然后根据其进行一些优化处理。对于GPU硬件参数的获取，当然我们可以根据GPU提供的手册进行查找，我们也可以使用程序进行查找。 我们可以使用cudaGetDeviceCount()函数来查看当前计算机中拥有多少个GPU设备，然后可以对每个设备进行迭代，并查询各个设备的相关信息。CUDA运行的时将返回一个cudaDeviceProp类型结构，其中包含了设备的相关属性。 在cudaDeviceProp结构中包含以下信息(本人的CUDA版本是8.0)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct __device_builtin__ cudaDeviceProp&#123; char name[256]; /**&lt; ASCII string identifying device ASCII字符串识别设备*/ size_t totalGlobalMem; /**&lt; Global memory available on device in bytes 设备上可用的全局内存(以字节为单位)*/ size_t sharedMemPerBlock; /**&lt; Shared memory available per block in bytes 以字节为单位的每个块可用的共享内存*/ int regsPerBlock; /**&lt; 32-bit registers available per block 每个块可用的32位寄存器*/ int warpSize; /**&lt; Warp size in threads 线程束的大小*/ size_t memPitch; /**&lt; Maximum pitch in bytes allowed by memory copies 内存拷贝允许的最大字节间距*/ int maxThreadsPerBlock; /**&lt; Maximum number of threads per block 每个块的最大线程数*/ int maxThreadsDim[3]; /**&lt; Maximum size of each dimension of a block 块的每个维度的最大大小*/ int maxGridSize[3]; /**&lt; Maximum size of each dimension of a grid 网格的每个维度的最大大小*/ int clockRate; /**&lt; Clock frequency in kilohertz 时钟频率（赫兹）*/ size_t totalConstMem; /**&lt; Constant memory available on device in bytes 设备上可用的常量内存(以字节为单位)*/ int major; /**&lt; Major compute capability 主要的计算能力*/ int minor; /**&lt; Minor compute capability 次要的计算能力*/ size_t textureAlignment; /**&lt; Alignment requirement for textures 纹理对齐要求*/ size_t texturePitchAlignment; /**&lt; Pitch alignment requirement for texture references bound to pitched memory 对纹理引用的调距要求绑定到倾斜内存。*/ int deviceOverlap; /**&lt; Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount. 设备可以同时复制内存并执行内核。弃用。使用相反asyncEngineCount。*/ int multiProcessorCount; /**&lt; Number of multiprocessors on device 设备上多处理器的数量*/ int kernelExecTimeoutEnabled; /**&lt; Specified whether there is a run time limit on kernels 指定内核是否有运行时限制。*/ int integrated; /**&lt; Device is integrated as opposed to discrete 设备是集成的，而不是离散的*/ int canMapHostMemory; /**&lt; Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer 设备可以使用cudaHostAlloc/cudaHostGetDevicePointer映射主机内存*/ int computeMode; /**&lt; Compute mode (See ::cudaComputeMode) 计算模式*/ int maxTexture1D; /**&lt; Maximum 1D texture size 最大1 d纹理大小*/ int maxTexture1DMipmap; /**&lt; Maximum 1D mipmapped texture size 最大1D的纹理错误处理*/ int maxTexture1DLinear; /**&lt; Maximum size for 1D textures bound to linear memory 绑定到线性内存的一维纹理的最大大小*/ int maxTexture2D[2]; /**&lt; Maximum 2D texture dimensions 最大的2 d纹理维度*/ int maxTexture2DMipmap[2]; /**&lt; Maximum 2D mipmapped texture dimensions 最大二维的纹理尺寸*/ int maxTexture2DLinear[3]; /**&lt; Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory 最大尺寸(宽度，高度，pitch)的二维纹理绑定到pitch内存*/ int maxTexture2DGather[2]; /**&lt; Maximum 2D texture dimensions if texture gather operations have to be performed 如果必须执行纹理收集操作，则最大的二维纹理尺寸*/ int maxTexture3D[3]; /**&lt; Maximum 3D texture dimensions 最大的3 d纹理维度*/ int maxTexture3DAlt[3]; /**&lt; Maximum alternate 3D texture dimensions 最大的替代3D纹理尺寸。*/ int maxTextureCubemap; /**&lt; Maximum Cubemap texture dimensions 最大Cubemap纹理维度*/ int maxTexture1DLayered[2]; /**&lt; Maximum 1D layered texture dimensions 最大1D层状纹理尺寸*/ int maxTexture2DLayered[3]; /**&lt; Maximum 2D layered texture dimensions 最大二维分层纹理尺寸*/ int maxTextureCubemapLayered[2];/**&lt; Maximum Cubemap layered texture dimensions 最大立方体地图分层纹理尺寸*/ int maxSurface1D; /**&lt; Maximum 1D surface size 最大1 d表面大小*/ int maxSurface2D[2]; /**&lt; Maximum 2D surface dimensions 最大的2 d表面尺寸*/ int maxSurface3D[3]; /**&lt; Maximum 3D surface dimensions 最大的3 d表面尺寸*/ int maxSurface1DLayered[2]; /**&lt; Maximum 1D layered surface dimensions 最大一维分层表面尺寸。*/ int maxSurface2DLayered[3]; /**&lt; Maximum 2D layered surface dimensions 最大二维分层表面尺寸。*/ int maxSurfaceCubemap; /**&lt; Maximum Cubemap surface dimensions 最大Cubemap表面尺寸*/ int maxSurfaceCubemapLayered[2];/**&lt; Maximum Cubemap layered surface dimensions 最大体积层状表面尺寸*/ size_t surfaceAlignment; /**&lt; Alignment requirements for surfaces 表面对齐要求*/ int concurrentKernels; /**&lt; Device can possibly execute multiple kernels concurrently 设备可以同时执行多个内核*/ int ECCEnabled; /**&lt; Device has ECC support enabled 设备已启用ECC支持*/ int pciBusID; /**&lt; PCI bus ID of the device 设备的PCI总线ID*/ int pciDeviceID; /**&lt; PCI device ID of the device 设备的PCI设备ID。*/ int pciDomainID; /**&lt; PCI domain ID of the device 设备的PCI域ID*/ int tccDriver; /**&lt; 1 if device is a Tesla device using TCC driver, 0 otherwise 如果设备是使用TCC驱动的特斯拉设备为1，则为0*/ int asyncEngineCount; /**&lt; Number of asynchronous engines 异步的引擎*/ int unifiedAddressing; /**&lt; Device shares a unified address space with the host 设备与主机共享统一的地址空间*/ int memoryClockRate; /**&lt; Peak memory clock frequency in kilohertz 峰值记忆时钟频率，单位为千赫兹*/ int memoryBusWidth; /**&lt; Global memory bus width in bits 全局内存总线宽度的位。*/ int l2CacheSize; /**&lt; Size of L2 cache in bytes 以字节为单位的L2缓存大小*/ int maxThreadsPerMultiProcessor;/**&lt; Maximum resident threads per multiprocessor 每个多处理器的最大驻留线程。*/ int streamPrioritiesSupported; /**&lt; Device supports stream priorities 设备支持流的优先级*/ int globalL1CacheSupported; /**&lt; Device supports caching globals in L1 设备支持在L1中缓存全局变量*/ int localL1CacheSupported; /**&lt; Device supports caching locals in L1 设备支持L1中的缓存局部变量*/ size_t sharedMemPerMultiprocessor; /**&lt; Shared memory available per multiprocessor in bytes 每个多处理器可用的共享内存(以字节为单位)*/ int regsPerMultiprocessor; /**&lt; 32-bit registers available per multiprocessor 每个多处理器可使用32位寄存器*/ int managedMemory; /**&lt; Device supports allocating managed memory on this system 设备支持在这个系统上分配托管内存*/ int isMultiGpuBoard; /**&lt; Device is on a multi-GPU board 设备在一个多gpu板上。*/ int multiGpuBoardGroupID; /**&lt; Unique identifier for a group of devices on the same multi-GPU board 一组设备的唯一标识符，在同一个多gpu板上。*/ int hostNativeAtomicSupported; /**&lt; Link between the device and the host supports native atomic operations 设备和主机之间的链接支持本地原子操作*/ int singleToDoublePrecisionPerfRatio; /**&lt; Ratio of single precision performance (in floating-point operations per second) to double precision performance 单精度性能(每秒浮点运算)与双精度性能的比值*/ int pageableMemoryAccess; /**&lt; Device supports coherently accessing pageable memory without calling cudaHostRegister on it 设备支持连贯地访问可分页内存，而不调用cudaHostRegister*/ int concurrentManagedAccess; /**&lt; Device can coherently access managed memory concurrently with the CPU 设备可以与CPU同步访问托管内存*/&#125;; 使用CUDA程序读取GPU参数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//CUDA头文件#include "cuda_runtime.h"#include "device_launch_parameters.h"//C语言的头文件#include "stdio.h"int main()&#123; //定义cudaDeviceProp结构用于读取参数 cudaDeviceProp prop; int count; //读取设备的数量 cudaGetDeviceCount(&amp;count); printf("GPU_count = %d\n\n",count); for(int i=0;i&lt;count;i++) &#123; //获取相应设备号的设备信息 cudaGetDeviceProperties(&amp;prop,i); printf(" --- General Information for device %d ---\n",i); //显卡名称 printf("Name:\t%s\n",prop.name); //计算能力 printf("Compute capability:\t%d.%d\n",prop.major,prop.minor); //时钟频率 printf("Clock rate:\t%d\n",prop.clockRate); //设备复制重叠 printf("Device copy overlap:\t"); if(prop.deviceOverlap) &#123; printf("Enable\n"); &#125; else &#123; printf("Disable\n"); &#125; //内核执行超时 printf("Kernel execition timeout:\t"); if(prop.kernelExecTimeoutEnabled) &#123; printf("Enable\n"); &#125; else &#123; printf("Disable\n"); &#125; printf(" --- Memory Information for device %d ---\n",i); //设备上全局内存的总量，单位为字节 printf("Total global Mem:\t%ld\n",prop.totalGlobalMem); //设备上的常量内存的总量，单位为字节 printf("Total constant Mem:\t%ld\n",prop.totalConstMem); //内存拷贝允许的最大字节间距 printf("Max men pitch:\t%ld\n",prop.memPitch); //纹理对齐要求 printf("Texture Alignment:\t%ld\n",prop.textureAlignment); printf(" ---MP Information for device %d ---\n",i); //设备上多处理器的数量 printf("Multiprocessor count:\t%d\n",prop.multiProcessorCount); //以字节为单位的每个块可用的共享内存 printf("Shared mem per mp:\t%ld\n",prop.sharedMemPerBlock); //每个块可用的32位寄存器 printf("Registers per mp:\t%d\n",prop.regsPerBlock); //每个warp包含的线程数量 printf("Threads in warp:\t%d\n",prop.warpSize); //每个块包含的最大线程数量 printf("Max threads per block:\t%d\n",prop.maxThreadsPerBlock); //块的每个维度的最大大小 printf("Max threads dimensions:\t(%d, %d, %d)\n",prop.maxThreadsDim[0],prop.maxThreadsDim[1],prop.maxThreadsDim[3]); //网格的每个维度的最大大小 printf("Max grid dimensions:\t(%d, %d, %d)\n",prop.maxGridSize[0],prop.maxGridSize[1],prop.maxGridSize[3]); printf("\n\n"); &#125;&#125; 四、参考《GPU高性能编程CUDA实战》 https://blog.csdn.net/zhangfuliang123/article/details/78115163 https://blog.csdn.net/q583956932/article/details/78700942]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows远程链接问题]]></title>
    <url>%2F2018%2F05%2F11%2Fwindows-link%2F</url>
    <content type="text"><![CDATA[windows远程链接问题最近因为微软的更新我们在远程链接windows服务器的时候会出现如下问题： 使用微软官方建议修改本地组策略：计算机配置&gt;管理模板&gt;系统&gt;凭据分配&gt;加密Oracle修正 选择启用并选择易受攻击。 但是我们是win 10 家庭版没有组策略，我也尝试过网上添加的方式。如下： 1、打开txt复制以下代码：1234567891011@echo offpushd &quot;%~dp0&quot;dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txtdir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txtfor /f %%i in (&apos;findstr /i . List.txt 2^&gt;nul&apos;) do dism /online /norestart /add-package:&quot;C:\Windows\servicing\Packages\%%i&quot;pause 2、保存后，后缀改为cmd 3、管理员身份运行cmd文件 4、win+r弹出运行窗口，输入gpedit.msc,打开本地组策略 但是我们好像无法找到加密Oracle修正这一项。 解决方法一我们没办法添加组策略，那么我最终选择就是卸载掉微软的更新。在控制面板，卸载程序，左边找到产看已安装的更新，翻到最底下找到如下的更新卸载后重启电脑即可。【但是这种方法不好的是我们在关机后卸载掉的更新又会回来，这样很不方便】 解决方法二(较好的方法)1、运行regedit，打开注册表 2、找文件夹 路径： 计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters（正常情况下只会到System，需要手动添加后两项路径） 3、再在Parameters里面 新建 DWORD（32）位，文件名 “AllowEncryptionOracle” ，值 : 2. 4、保存后如未生效，重启计算机 即可开启桌面远程连接]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer刷题（30）：连续子数组的最大和]]></title>
    <url>%2F2018%2F04%2F07%2F30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[剑指offer刷题（30）：连续子数组的最大和刷题平台：牛客网 连续子数组的最大和考点：动态规划 1、题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 2、解题思路从第一个数字开始，往后加，如果前面的和大于0，那么我们将要继续往下累加就好；否则我们将要重新归零，然后再往下累加。在累加的时候，一旦我们求得最大值的时候我们就可以记录子数组结束的位置。 3、算法实现C实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include "stdio.h"void FindGreatestSumOfSubArray(int *a, int *length, int *start, int *end, int *sum_max);void FindGreatestSumOfSubArray(int *a, int *length, int *start, int *end, int *sum_max)&#123; if (length &lt;= 0) &#123; return; &#125; *sum_max = a[0]; int sum_max_old = a[0]; for (int i = 1; i &lt; *length; i++) &#123; if (*sum_max &lt; 0) &#123; *sum_max = 0; &#125; *sum_max += a[i]; if (*sum_max &lt; 0) &#123; if (*sum_max &gt; sum_max_old) &#123; sum_max_old = *sum_max; *start = i; *end = i; &#125; *sum_max = 0; *start = i + 1; &#125; else &#123; if (*sum_max &gt; sum_max_old) &#123; *end = i; sum_max_old = *sum_max; &#125; &#125; &#125; if (*start &gt; *end) &#123; *start = *end; &#125; *sum_max = sum_max_old;&#125;int main()&#123; int num[] = &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4 &#125;;//−2,1,−3,4,−1,2,1,−5,4 int length = sizeof(num) / sizeof(num[0]); int start = 0, end = 0, sum_max=0; printf("我们需要计算的数组"); for (int i = 0; i &lt; length; i++) &#123; printf("%d\t",num[i]); &#125; printf("\n"); FindGreatestSumOfSubArray(num, &amp;length, &amp;start, &amp;end, &amp;sum_max); printf("\n\n"); printf("连续子数组的最大和为："); printf("%d\n", sum_max); printf("连续子数组的最大和的起止坐标为:（%d,%d）\n", start, end); printf("连续子数组为："); for (int i = start; i &lt;= end; i++) &#123; if (start == end) &#123; printf("%d\t", num[end]); &#125; else &#123; printf("%d\t", num[i]); &#125; &#125; printf("\n"); &#125; 实现结果]]></content>
      <tags>
        <tag>剑指offer刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer刷题（11）：二进制中1的个数]]></title>
    <url>%2F2018%2F04%2F07%2F11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[剑指offer刷题（11）：二进制中1的个数刷题平台：牛客网 二进制中1的个数考点：位运算 1、题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 2、解题思路一个数只要不为0，该数的二进制至少有一位为1，然后减去1以后原来最后的1变成0，原来1后面的0全变成1，这样并不会影响其余位置的变化，与原来的数求完与操作我们会发现原来数据中少了一个1，依次进行直到与操作为0为止。 例子：123456789111000总共有3个1：下面是计算过程：因为111000不等于0，所以计算标志位count=1;111000-1=110111,与原来的数据求与操作得到110000；因为110000不等于0，所以计算标志位conut+1,故count=2；同理110000-1=101111，与110000求与为100000；count=3；100000-1=011111，与100000求与操作000000；因为000000=0，所以最终的结果为count=3；故111000总共有3个1. 3、算法实现C/C++实现123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int count=0; while(n!=0) &#123; count++; n=(n-1)&amp;n; &#125; return count; &#125;&#125;;]]></content>
      <tags>
        <tag>剑指offer刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer刷题（2）：空格替换]]></title>
    <url>%2F2018%2F04%2F07%2F2-%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[剑指offer刷题（2）：空格替换刷题平台：牛客网 空格替换考点：字符串 1、题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 2、解题思路 1、思路一：从前往后依次查找空格，然后依次挪并且将空格替换成“%20”；该方法的计算复杂度为$O( n^2 )$,因为空格后面的数据有可能重复的移动，所以该方法并不好。 2、思路二：我们可以先扫面一遍字符串，然后记录下该字符串中的空格数num_space,然后替换玩以后的数据新的长度new_length应该为length+2*num_space，此时我们在从后往前不停的复制数据，并且在遇到了空格的时候将其替换成“%20”。在该方法中所有的数据只会被移动一次，所以计算复杂度为$O(n)$。 3、算法实现C/C++实现123456789101112131415161718192021222324252627class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int num_space=0; for(int i=0;i&lt;length;i++) &#123; if(str[i]==' ') &#123; num_space++; &#125; &#125; int new_length=length+2*num_space; for(int i=length;i&gt;=0;i--) &#123; if(str[i]!=' ') &#123; str[new_length--]=str[i]; &#125; else &#123; str[new_length--]='0'; str[new_length--]='2'; str[new_length--]='%'; &#125; &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>剑指offer刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer刷题（1）：二维数组中的查找]]></title>
    <url>%2F2018%2F04%2F07%2F1-%E4%BA%8C%E4%BD%8D%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[剑指offer刷题（1）：二维数组中的查找刷题平台：牛客网 二维数组中的查找考点：数组 1、题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 2、解题思路对于一个二维数组，每一行都按照从左到右递增的顺序，每一列都按照从上到下递增的顺序排列，那么我们要想实现在这个数组中查找一个数。我们可以有很多个思路： 1、从第一个数据向后或者最后一个数据向前挨个查找一遍，直至查到该数据或者查完所有数据为止。虽然这种方法可以实现，但是比较麻烦。 2、我们可以利用数组行列都是递增的这么一个关系，因此我们可以从数组的左下角或者右上角开始查找，让所需要查找的数组与左下角或者右上角的数据进行比较，这样我们就可以利用矩阵的特性来不断的缩小数据应该出现的范围，从而可以很快的找出数据，当然也可以很快的确定该数据是否存在与改数组中。 3、算法实现C实现为了方便这里的矩阵我并没有手动输入，而是直接放在程序里面的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include "stdio.h"bool Find(int targe, int *array, int rows, int cols);bool Find(int targe, int *array, int rows, int cols)&#123; int i = rows - 1, j = 0; while (i &gt; 0 &amp;&amp; j &lt; cols) &#123; if (targe &lt; array[cols * i + j]/**((int *)array + cols * i + j)*/ /*array[i][j]*/) &#123; i--; &#125; else if (targe&gt;array[cols * i + j] /**((int *)array + cols * i + j)*/ /*array[i][j]*/) &#123; j++; &#125; else &#123; printf("找到了该数，位置为（%d,%d）\t第%d行,第%d列\n",i,j,i+1,j+1); return true; &#125; &#125; printf("该数组中没有该数。\n"); return false;&#125;int main()&#123; //先定义一个二维数组 int a[5][5] = &#123; &#123; 1, 2, 3, 4, 5 &#125;, &#123; 6, 7, 8, 9, 10 &#125;, &#123; 11, 12, 13, 14, 15 &#125;, &#123; 16, 17, 18, 19, 20 &#125;, &#123; 21, 22, 23, 24, 25 &#125; &#125;; int targe=0; int cols = sizeof(a[0]) / sizeof(a[0][0]); int rows = sizeof(a) / sizeof(a[0]); printf("二维数组为：\n"); for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; printf("%d\t", a[i][j]); &#125; printf("\n"); &#125; printf("\n矩阵的大小为：rows=%d\tcols=%d\n", rows, cols); printf("请输入需要查询的数字：\n"); scanf_s("%d", &amp;targe); printf("需要查询的数字为：%d\n",targe); Find(targe, *a, rows, cols);&#125; C++实现123456789101112131415161718192021222324class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int rows=array.size(); int cols=array[0].size(); int i=rows-1,j=0; while(i&gt;=0&amp;&amp;j&lt;cols) &#123; if(target&lt;array[i][j]) &#123; i--; &#125; else if (target&gt;array[i][j]) &#123; j++; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125;; C语言实现结果]]></content>
      <tags>
        <tag>剑指offer刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序参考：https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95 http://cuijiahua.com/blog/2017/12/algorithm_4.html 一、原理基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 二、步骤设要排序的数组是$A_{[0]}……A_{[N-1]}$，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j—)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 三、例子假设有一组数{6,10,1,2,8,5,9,7,3,4,0}12下标 0 1 2 3 4 5 6 7 8 9 10数据 6 10 1 2 8 5 9 7 3 4 0 此时i=0,j=10,key=6 从右边开始把比key小的值与0位的6进行换位操作。因此对于上述例子，右边第一个数为0，比6小，进项换位操作，完成第一次比较：12下标 0 1 2 3 4 5 6 7 8 9 10数据 0 10 1 2 8 5 9 7 3 4 6 此时i=0，j=10,key=6 接着进行第二次比较，从左边开始把比6大的数字与6进行换位操作，完成第二次比较：12下标 0 1 2 3 4 5 6 7 8 9 10数据 0 6 1 2 8 5 9 7 3 4 10 上面两次比较是一个循环，接下来递减变量j和i,只需要不断的重复上面的操作，直至i=j为止。 然后，对key两边的数据，再分组分别进行上述的过程，直到不能再分组为止。 四、算法实现C语言12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include "stdio.h"void quick_sort(int a[], int left, int right);void quick_sort(int a[], int left, int right)&#123; if (left &gt;= right) &#123; return; &#125; int i = left; int j = right; int key = a[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; key &lt;= a[j]) &#123; j--; &#125; a[i] = a[j]; while (i &lt; j &amp;&amp; key &gt;= a[i]) &#123; i++; &#125; a[j] = a[i]; &#125; a[i] = key; quick_sort(a, left, i - 1); quick_sort(a, i + 1, right);&#125;int main()&#123; int number[] = &#123; 6,10,1,2,8,5,9,7,3,4,0 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); quick_sort(number, 0,n-1); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序参考：https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F http://cuijiahua.com/blog/2018/01/algorithm_8.html 一、原理基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 二、步骤 1、将所有数据从低位开始，按照0~9进行归类 2、将归完的数据整理好，这就进行了一次排序 3、重复执行前两步直到最高位也排完序了，此时整理完数据就是排完的序列 三、例子（借用百度百科的例子） 第一步 以LSD为例，假设原来有一串数值如下所示： 73, 22, 93, 43, 55, 14, 28, 65, 39, 81 首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：1234567891001 812 223 73 93 434 145 55 65678 289 39 第二步 接下来将这些桶子中的数值重新串接起来，成为以下的数列： 81, 22, 73, 93, 43, 14, 55, 65, 28, 39 接着再进行一次分配，这次是根据十位数来分配：1234567891001 142 22 283 394 435 556 657 738 819 93 第三步 接下来将这些桶子中的数值重新串接起来，成为以下的数列： 14, 22, 28, 39, 43, 55, 65, 73, 81, 93 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。 LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。 四、算法实现C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdio.h"#include "math.h"void bucketSort3(int *p, int n);int getLoopTimes(int num);int findMaxNum(int *p, int n);void sort2(int *p, int n, int loop);//基数排序void bucketSort3(int *p, int n)&#123; //获取数组中的最大数 int maxNum = findMaxNum(p, n); //获取最大数的位数，次数也是再分配的次数。 int loopTimes = getLoopTimes(maxNum); int i; //对每一位进行桶分配 for (i = 1; i &lt;= loopTimes; i++) &#123; sort2(p, n, i); printf("第%d次循环：\t", i); for (int j = 0; j &lt; n; j++) &#123; printf("%d\t", p[j]); &#125; printf("\n"); &#125;&#125;//获取数字的位数int getLoopTimes(int num)&#123; int count = 1; int temp = num / 10; while (temp != 0) &#123; count++; temp = temp / 10; &#125; return count;&#125;//查询数组中的最大数int findMaxNum(int *p, int n)&#123; int i; int max = 0; for (i = 0; i &lt; n; i++) &#123; if (*(p + i) &gt; max) &#123; max = *(p + i); &#125; &#125; return max;&#125;//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果void sort2(int *p, int n, int loop)&#123; //建立一组桶此处的20是预设的根据实际数情况修改 int buckets[10][20] = &#123;&#125;; //求桶的index的除数 //如798个位桶index=(798/1)%10=8 //十位桶index=(798/10)%10=9 //百位桶index=(798/100)%10=7 //tempNum为上式中的1、10、100 int tempNum = (int)pow((float)10, loop - 1); int i, j; for (i = 0; i &lt; n; i++) &#123; int row_index = (*(p + i) / tempNum) % 10; for (j = 0; j &lt; 20; j++) &#123; if (buckets[row_index][j] == NULL) &#123; buckets[row_index][j] = *(p + i); break; &#125; &#125; &#125; //将桶中的数，倒回到原有数组中 int k = 0; for (i = 0; i &lt; 10; i++) &#123; for (j = 0; j &lt; 20; j++) &#123; if (buckets[i][j] != NULL) &#123; *(p + k) = buckets[i][j]; buckets[i][j] = NULL; k++; &#125; &#125; &#125;&#125;int main()&#123; int a[] = &#123; 73, 22, 93, 43, 55, 14, 28, 65, 39, 81 &#125;;//&#123; 2, 343, 342, 1, 123, 43, 4343, 433, 687, 654, 3 &#125;;// int *a_p = a; int i; //计算数组长度 int size = sizeof(a) / sizeof(int); printf("原始数据：\n"); for (i = 0; i &lt; size; i++) &#123; printf("%d\t", a[i]); &#125; printf("\n\n"); //基数排序 bucketSort3(a_p, size); //打印排序后结果 printf("\n返回结果：\n"); for (i = 0; i &lt; size; i++) &#123; printf("%d\t", a[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序参考：https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F http://cuijiahua.com/blog/2018/01/algorithm_7.html 一、原理归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 二、步骤 1、先将序列分为两组 2、分别对两组进行排序 3、进行归并 归并过程为：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。 三、算法实现C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void Merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex)&#123; int i = startIndex, j = midIndex + 1, k = startIndex; while (i != midIndex + 1 &amp;&amp; j != endIndex + 1) &#123; if (sourceArr[i] &gt; sourceArr[j]) tempArr[k++] = sourceArr[j++]; else tempArr[k++] = sourceArr[i++]; &#125; while (i != midIndex + 1) tempArr[k++] = sourceArr[i++]; while (j != endIndex + 1) tempArr[k++] = sourceArr[j++]; for (i = startIndex; i &lt;= endIndex; i++) sourceArr[i] = tempArr[i];&#125;//内部使用递归void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)&#123; int midIndex; if (startIndex &lt; endIndex) &#123; midIndex = (startIndex + endIndex) / 2; MergeSort(sourceArr, tempArr, startIndex, midIndex); MergeSort(sourceArr, tempArr, midIndex + 1, endIndex); Merge(sourceArr, tempArr, startIndex, midIndex, endIndex); &#125;&#125;int main()&#123; int number[] = &#123; 0, 10, 1, 2, 8, 5, 9, 7, 3, 4, 6 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); //int result[11] = &#123;0&#125;; int *result = (int *)malloc(n * sizeof(int)); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); MergeSort(number, result,0,n-1); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", result[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单选择排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单选择排序参考：https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F http://cuijiahua.com/blog/2017/12/algorithm_5.html 一、原理简单选择排序就是从左边开始，找到最小的数字，然后进行换位操作即可。 二、步骤 1、先找到整个序列中最小的值，然后跟最左边0位进行换位操作； 2、从1位（即就是第二个数字）开始找到最小的数跟1位进行换位操作； 3、依此进行最小值的查找并进行换位操作，直至最后。 三、例子假设有一组数{0,10,1,2,8,5,9,7,3,4,6} 123456789101112排序前： 0 10 1 2 8 5 9 7 3 4 6第一次： 0 10 1 2 8 5 9 7 3 4 6 第二次： 0 1 10 2 8 5 9 7 3 4 6 第三次： 0 1 2 10 8 5 9 7 3 4 6 第四次： 0 1 2 3 8 5 9 7 10 4 6第五次： 0 1 2 3 4 5 9 7 10 8 6 第六次： 0 1 2 3 4 5 9 7 10 8 6第七次： 0 1 2 3 4 5 6 7 10 8 9第八次： 0 1 2 3 4 5 6 7 10 8 9第九次： 0 1 2 3 4 5 6 7 8 10 9第十次： 0 1 2 3 4 5 6 7 8 9 10 四、算法实现C语言12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include "stdio.h"void select_sort(int a[], int n);void select_sort(int a[], int n)&#123; int i,j,t; for (i = 0; i&lt;n-1; i++)//最后就一个数字了不用找最小值换了 &#123; t = i; for (j = i + 1; j&lt;n; j++) &#123; if (a[t]&gt;a[j]) &#123; t = j; &#125; &#125; int temp = a[i]; a[i] = a[t]; a[t] = temp; printf("第%d次循环：\t", i+1); for (j = 0; j &lt; n; j++) &#123; printf("%d\t", a[j]); &#125; printf("\n"); &#125;&#125;int main()&#123; int number[] = &#123; 0, 10, 1, 2, 8, 5, 9, 7, 3, 4, 6 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); select_sort(number, n); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序参考：https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306 http://cuijiahua.com/blog/2017/12/algorithm_1.html 一、原理1、比较两个相邻元素的大小。如果前面的比后面的大则交换位置，否则不变。2、依次循环第一步的操作，直到最后一对数字结束，最后一个数字一定是这组数字中最大的那一个 3、依次进行上述操作（除了每次得到的最大的数） 4、循环上述操作直到没有可以比较的数字为止，我们就已经得到了最终的排序 二、优化其实当我们进行比较的时候，如果前面的比较都没有进行换位操作的话，即证明前面的顺序是对的，所以此时我们可以设置一个标志位停止掉后面的循环操作。这样我们就可以节省掉很多的时间。 三、算法实现C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include "stdio.h"void bubble_sort(int a[], int n);void bubble_sort(int a[], int n)&#123; int i, j, temp, exchange_num; for (j = 0; j &lt; n - 1; j++) &#123; exchange_num = 0; for (i = 0; i &lt; n - 1 - j; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; exchange_num++; &#125; &#125; printf("第%d次循环,交换了%d次：\t", j + 1, exchange_num); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", a[i]); &#125; printf("\n"); if (exchange_num == 0) &#123; printf("\nbreak bubble_sort\n"); break; &#125; &#125; &#125;int main()&#123; int number[] = &#123; 0,10,1,2,8,5,9,7,3,4,6 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); bubble_sort(number, n); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序参考：https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F http://cuijiahua.com/blog/2017/12/algorithm_3.html 一、原理希尔排序是插入排序的一种，又称“缩小增量排序”，是直接插入排序的一种高效改进版。 二、步骤 1、先取一个增量$a_{1}$,然后将待排序的序列按照将距离为$a_{1}$的数放在一组中的原则分成n组，（最后不够$a_{1}$个的数也为一组） 2、将所有组数分别进行直接插入排序 3、排好序后再将所有组的数拼接在一起 4、重新选择一个增量$a_{2}$，使得$a_{2}&lt;a_{1}$，然后重复上诉步骤即可，直到增量为1，排序完成 三、例子假设有一组数{0,10,1,2,8,5,9,7,3,4,6}，增量步长为3进行排序：1230 2 9 410 8 7 61 5 3 对每组进行直接插入语排序1230 2 4 96 7 8 101 3 5 将上述每组元素依此拼接在一起得到{0,2,4,9,6,7,8,10,1,3,5},然后在以2为增量步长进行排序：120 4 6 8 1 52 9 7 10 3 对每组进行直接插入排序120 1 4 5 6 82 3 7 9 10 最后再以1为增量步长进行排序（就是简单的直接插入排序了）。 四、算法实现C语言1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include "stdio.h"void shell_sort(int a[], int n);void shell_sort(int a[], int n)&#123; int gap,i,j,temp,loop_num=0; for (gap = n &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;=1) &#123; loop_num++; for (i = gap; i &lt; n; i++) &#123; temp = a[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; a[j]&gt;temp) &#123; a[j + gap] = a[j]; j -= gap; &#125; a[j + gap] = temp; &#125; printf("第%d次循环,gap=%d：\t", loop_num,gap); for (j = 0; j &lt; n; j++) &#123; printf("%d\t", a[j]); &#125; printf("\n"); &#125;&#125;int main()&#123; int number[] = &#123; 0,10,1,2,8,5,9,7,3,4,6 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); shell_sort(number, n); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序参考：https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151 http://cuijiahua.com/blog/2018/01/algorithm_6.html 一、原理堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即$A_{[PARENT_{[i]}]} &gt;= A_{[i]}$。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 堆是一棵顺序存储的完全二叉树。 其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。 其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。举例来说，对于n个元素的序列${R_{0}, R_{1}, … , R_{n}}$当且仅当满足下列关系之一时，称之为堆： $R_{i}&lt;=R_{2i+1}$ 且 $R_{i}&lt;=R_{2i+2}$ (小根堆) $R_{i}&gt;=R_{2i+1}$ 且 $R_{i}&gt;=R_{2i+2}$ (大根堆)其中i=1,2,…,n/2向下取整； 二、步骤设当前元素在数组中以R[i]表示，那么， (1) 它的左孩子结点是：R[2*i+1]; (2) 它的右孩子结点是：R[2*i+2]; (3) 它的父结点是：R[(i-1)/2]; (4) R[i] &lt;= R[2*i+1] 且 R[i] &lt;= R[2i+2]。 首先，按堆的定义将数组R[0..n]调整为堆（这个过程称为创建初始堆），交换R[0]和R[n]； 然后，将R[0..n-1]调整为堆，交换R[0]和R[n-1]； 如此反复，直到交换了R[0]和R[1]为止。 以上思想可归纳为两个操作： （1）根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。 （2）每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。 当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。 三、算法实现C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;void adjustHeap(int param1, int j, int inNums[]);void HeapSort(int nums, int inNums[]);//大根堆进行调整void adjustHeap(int param1, int j, int inNums[])&#123; int temp = inNums[param1]; for (int k = param1 * 2 + 1; k&lt;j; k = k * 2 + 1) &#123; //如果右边值大于左边值，指向右边 if (k + 1&lt;j &amp;&amp; inNums[k]&lt; inNums[k + 1]) &#123; k++; &#125; //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换） if (inNums[k]&gt;temp) &#123; inNums[param1] = inNums[k]; param1 = k; &#125; else break; &#125; //put the value in the final position inNums[param1] = temp;&#125;//堆排序主要算法void HeapSort( int inNums[],int nums)&#123; int i, j; //1.构建大顶堆 for (i = nums / 2 - 1; i &gt;= 0; i--) &#123; //put the value in the final position adjustHeap(i, nums, inNums); &#125; //2.调整堆结构+交换堆顶元素与末尾元素 for (j = nums - 1; j&gt;0; j--) &#123; //堆顶元素和末尾元素进行交换 int temp = inNums[0]; inNums[0] = inNums[j]; inNums[j] = temp; adjustHeap(0, j, inNums);//重新对堆进行调整 printf("第%d次循环：\t", nums-j); for (i = 0; i &lt; nums; i++) &#123; printf("%d\t", inNums[i]); &#125; printf("\n"); &#125;&#125;int main()&#123; int number[] = &#123; 0, 10, 1, 2, 8, 5, 9, 7, 3, 4, 6 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); HeapSort(number, n); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接插入排序]]></title>
    <url>%2F2018%2F04%2F06%2F%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[直接插入排序参考：https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F http://cuijiahua.com/blog/2017/12/algorithm_2.html 一、原理每次将一条记录插入到已经排好的有序表中，从而得到了一个新的有序表。 二、步骤假设待排序记录 R_{0},R_{1},R_{2},...,R_{n-1},R_{n} 1、将第一个元素 R_{0} 视为一个元素为1的有序序列 2、依次将 R_{1},R_{2},...,R_{n-1},R_{n} 插入到前面的有序序列中，每插入一次有序序列的元素数个数加1 3、直到 R_{n} 也插入到序列中的时候，排序完成 三、算法实现C语言1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include "stdio.h"void insert_sort(int a[], int n);void insert_sort(int a[], int n)&#123; int i, j, temp; for (i = 1; i &lt; n; i++) &#123; if (a[i] &lt; a[i - 1]) &#123; temp = a[i]; for (j = i - 1; j &gt; 0 &amp;&amp; a[j] &gt; temp; j--) &#123; a[j + 1] = a[j]; &#125; a[j+1] = temp; &#125; printf("第%d次循环：\t", i); for (j = 0; j &lt; n; j++) &#123; printf("%d\t", a[j]); &#125; printf("\n"); &#125;&#125;int main()&#123; int number[] = &#123; 0,10,1,2,8,5,9,7,3,4,6 &#125;; int i; int n = sizeof(number) / sizeof(number[0]); printf("原始数据：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n\n"); insert_sort(number, n); printf("\n返回结果：\n"); for (i = 0; i &lt; n; i++) &#123; printf("%d\t", number[i]); &#125; printf("\n");&#125; 运行结果]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvidia驱动挂掉]]></title>
    <url>%2F2018%2F01%2F16%2Fnvidia%E9%A9%B1%E5%8A%A8%E6%8C%82%E6%8E%89%2F</url>
    <content type="text"><![CDATA[nvidia驱动挂掉linux系统中，在内核自动升级后英伟达的驱动有时候会找不到，以至于驱动用不了，装的CUDA等都找不到。 或者无法链接NVIDIA驱动：NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver 解决方法以下是自己的解决方法。 我们选择使用dkms这个包来对驱动进行管理。 在此之前我们应该先查看一下gcc和g++的版本，这个可能会影响我们的编译，【同时也有可能时gcc和g++的版本被我们降低了才导致了驱动更新没有跟上】我们要将这两个版本调到原来系统的版本（如果有多版本的话），当然gcc和g++应该处于同一个版本。调整gcc和g++的版本可以参考以前的博客ubuntu环境下降低gcc和g++的版本 方法一：安装dkms1sudo apt install dkms 查看dkms的状态 1dkms status 使用dkms挂载nvidia 1dkms nvidia 使用dkms自动安装 1sudo dkms autoinstall 方法二：nvcc -V可以找到驱动 step1：sudo apt-get install dkms step2: sudo dkms install -m nvidia -v 410.48 其中step2 中的410.48是NVIDIA的版本号，进入/usr/src目录中，可以看到里面有nvidia文件夹，后缀就是其版本号 本人使用以上的方法解决了因为内核更新导致的驱动版本没有跟上的问题。作为笔记供日后查看。 注： 安装内核1sudo apt install linux-headers-generic 查看错误信息1cat /var/lib/dkms/nvidia/375.26/build/make.log]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器之间免密配置]]></title>
    <url>%2F2017%2F12%2F02%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%8D%E5%AF%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[服务器之间免密配置主要用于服务器之间的通信。 当服务器没有禁用密码登陆的时候，我们服务器之间通信可以通过密码登陆，比如ssh和scp指令的操作可以使用密码来操作。但是如果其中一台服务器设置了禁止密码登陆的话，连接该机子将会受阻；同理两台机子如果都禁用了密码登陆的话，两台机子之间的互相连接都会受阻。因此我们要设置两台机子之间的免密登陆。 方法一在之前的博客“hadoop集群安装”中，其中就有一个ssh无密码登陆节点的配置的过程。 不过如果有一台机子已经设置过禁止密码登陆了，这种方法中使用scp传输id_rsa.pub文件将会受阻。此时可以使用方法二。。 方法二该方法比较简单粗暴，就跟之前博客“Ubuntu 系统设置密钥登陆”一样，给两台电脑互换公钥即可。 具体操作为： 在两台机子上执行 ssh-keygen 用于生成机子的公钥，如果有的话可以直接用，或者删了重新生成都可。 接着复制服务器1中 ~/.ssh/id_rsa.pub中的公匙到服务器2中的~/.ssh/authorized_keys同理将服务器2中的也复制到服务器1中对应的位置即可。 注： 可以直接使用cat指令进行查看id_rsa.pub中的公匙。 更改authorized_keys的文件模式 chmod 600 authorized_keys]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XX-net]]></title>
    <url>%2F2017%2F11%2F29%2FXX-net%2F</url>
    <content type="text"><![CDATA[使用XX-net进行上网xx-net个人用它来上外网的。 参考网址：https://github.com/XX-net/XX-Net 1、安装谷歌浏览器 2、下载或者使用git克隆xx-net软件； https://github.com/XX-net/XX-Net.git 3、将文件放置到希望安装的位置，然后运行 start.vbs即可。 完成上面的步骤，如果使用的是学校的网络，那么应该就可以直接上外网了，如果是自己寝室的网络需要根据上面的提示设置一下IPV6然后重新启动计算机即可。 这个时候使用的是公共appid，当然你也可以用你自己的谷歌账户创建自己的appid，一个谷歌账户可以创建12个appid.直接点配置文件重点的怎么申请即可。 IPV6开启参考网址： https://github.com/XX-net/XX-Net/wiki/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFIPv6 设置如下： // 设置 Teredo 服务器，默认为：win10.ipv6.microsoft.com netsh interface teredo set state enterpriseclient server=default ping -6 ipv6.test-ipv6.com // 重置 IPv6 配置 netsh interface ipv6 reset]]></content>
      <tags>
        <tag>工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VXL库的简单使用]]></title>
    <url>%2F2017%2F11%2F07%2FVXL%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[VXL库该库是进行矩阵运算的一个矩阵库，个人感觉使用起来跟eigen库还是比较像，毕竟都是基于C++编写的矩阵运算库。 资源该库是ITK这个开源项目中的数学计算部分，ITK是一个开源的跨平台的图像分析算法研究平台。感觉国内使用的人好像并不是很多，所以之前找到的资料也比较少，下面是自己找到的资源的链接： http://xueshu.baidu.com/s?wd=%E5%9F%BA%E4%BA%8EITK%E6%95%B0%E5%AD%A6%E5%BA%93%E7%9A%84%E7%9F%A9%E9%98%B5%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97&amp;rsv_bp=0&amp;tn=SE_baiduxueshu_c1gjeupa&amp;rsv_spt=3&amp;ie=utf-8&amp;f=8&amp;rsv_sug2=1&amp;sc_f_para=sc_tasktype%3D%7BfirstSimpleSearch%7D&amp;rsv_n=2 https://public.kitware.com/vxl/doc/release/ VXL库的下载我使用的是vxl-1.17.0可以直接百度下载： https://zh.osdn.net/projects/sfnet_vxl/downloads/vxl/1.17b/vxl-1.17.0-b.tar.gz/ 或者可以在我的github上进行下载： https://github.com/huanghailiang/vxl-1.17.0.git VXL库的简单使用在上面资源的链接中都有讲vxl这个库的使用，尤其VXL Documentation中更加全面。 下面是自己给的一些最常用到的一些简单的例子，如果后面有时间有兴趣的话会接着更新，如果没有就….. 编写CMakeList.txt来进行链接库生成工程，省去自己链接库的麻烦： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#=========================================================================# $Author$# $Date$# $Revision$#=========================================================================CMAKE_MINIMUM_REQUIRED(VERSION 2.4)IF(COMMAND cmake_policy) cmake_policy(SET CMP0003 NEW)ENDIF(COMMAND cmake_policy)PROJECT(VNL)FIND_PACKAGE(VXL) IF(VXL_FOUND) INCLUDE($&#123;VXL_CMAKE_DIR&#125;/UseVXL.cmake)ENDIF(VXL_FOUND)IF(WIN32)ADD_DEFINITIONS(-D_ALLOW_KEYWORD_MACROS)ENDIF(WIN32)#IF( VXL_VNL_FOUND ) INCLUDE_DIRECTORIES( $&#123;VXL_VNL_INCLUDE_DIR&#125; ) SET(IO_API_SRCS common.cpp ) file(GLOB_RECURSE IO_API_HDRS common.h ) ADD_LIBRARY(io_api $&#123;API_LIBRARY_TYPE&#125; $&#123;IO_API_SRCS&#125; $&#123;IO_API_HDRS&#125;)SET( VNL $&#123;VNL&#125; vnl_example.cpp )ADD_EXECUTABLE( VNL $&#123;VNL&#125;)TARGET_LINK_LIBRARIES( VNL io_api vnl_algo vnl vcl netlib) 自己照着编写的一些简单的使用例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**************************************************///该程序主要是为了学习使用VXL这个库而制作的//数字vnl库旨在为数字编程提供一个环境，结合了Mathematica和Matlab等软件的易用性，C的速度和C++的优雅。/**************************************************//*************************************************///矩阵的模板类/*************************************************/#include &lt;vnl/vnl_matrix.h&gt;#include &lt;vcl_iostream.h&gt;int main()&#123; //定义一个矩阵A而不给它设定大小 vnl_matrix&lt;double&gt; A; printf("A_rows=%d \t A_cols=%d\n", A.rows(), A.cols()); //定义一个矩阵B设定大小为3*5的矩阵,但是不给初值 vnl_matrix&lt;double&gt; B(3, 5); printf("B_rows=%d \t B_cols=%d\n", B.rows(), B.cols()); //定义一个矩阵C设定大小为3*5的矩阵，并且给任意的初值，这里设置初值为1 vnl_matrix&lt;double&gt; C(3, 5, 1); printf("C_rows=%d \t C_cols=%d\n", C.rows(), C.cols()); //矩阵输出，这个格式跟C++很像，不过需要包含 vcl_iostream.h 这个头文件 vcl_cerr &lt;&lt;" C 初值为1"&lt;&lt; vcl_endl; printf("C_rows=%d \t C_cols=%d\n", C.rows(), C.cols()); vcl_cerr &lt;&lt; C &lt;&lt; vcl_endl; //定义一个矩证D，初值为0 vnl_matrix&lt;double&gt; D(3, 3, vnl_matrix_null); vcl_cerr &lt;&lt;" D 初值为0 vnl_matrix_null"&lt;&lt; vcl_endl; printf("D_rows=%d \t D_cols=%d\n", D.rows(), D.cols()); vcl_cerr &lt;&lt; D &lt;&lt; vcl_endl; //单位矩阵 //定义一个 单位矩证 E ，单位矩阵的话，矩阵的长宽一定是一样大的 vnl_matrix&lt;double&gt; E(3, 3, vnl_matrix_identity); vcl_cerr &lt;&lt;" E 单位阵 vnl_matrix_identity"&lt;&lt; vcl_endl; printf("E_rows=%d \t E_cols=%d\n", E.rows(), E.cols()); vcl_cerr &lt;&lt; E &lt;&lt; vcl_endl; //矩阵的前n位(第三个参数)自动被数组赋值，其他位不变，行优先 double f[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 &#125;; vnl_matrix&lt;double&gt; F(3, 5, 10, f); vcl_cerr &lt;&lt; " F 前n位被数组自动赋值" &lt;&lt; vcl_endl; printf("F_rows=%d \t F_cols=%d\n", F.rows(), F.cols()); vcl_cerr &lt;&lt; F &lt;&lt; vcl_endl; //矩阵 double g[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 &#125;; vnl_matrix&lt;double&gt; G(g, 3, 5); vcl_cerr &lt;&lt; " G 被一块内存初始化" &lt;&lt; vcl_endl; printf("G_rows=%d \t G_cols=%d\n", G.rows(), G.cols()); vcl_cerr &lt;&lt; G &lt;&lt; vcl_endl;&#125;]]></content>
      <tags>
        <tag>工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMakeLists的编写]]></title>
    <url>%2F2017%2F11%2F01%2FCMakeLists%E7%9A%84%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[CMake工具的理解CMake是一个很方便的跨平台编译的软件，他可以输出各种各样的makefile或者project文件。因为本人经常需要将windows上编写的程序放到linux上进行编译运行等，所以如果自己手动去一个一个编译，去链接各种库；这个时候CMake就可以帮助我们来解决这些麻烦的问题，他不仅仅可以帮助我们生成相应的makefile和project，还会帮助我们去查找系统中所安装的一些依赖库，帮我们做好链接工作【当然，如果我们有些库没有设置环境变量的话，可能会找不到，但是这个时候在windows上我们可以手动添加，在linux上面我们可以通过ccmake来进入可视化界面进行添加或者使用cmake后面加上指令进行添加】。 当然CMake工具也要知道我们的工程需要干什么等，这个时候我们就需要编写CMakeLists.txt文件来告诉计算机我这个工程用到了哪些库，里面的文件是如何链接的等。 CMakeLists.txt的编写下面是我自己编写的一个例子： 在这个例子中，我生成了一个名字叫VNL的工程，并且在该工程中我链接了VXL这个库,并且有一个IO接口，这个IO中我们可以编写自己的函数然后生成lib供主函数来调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#=========================================================================# $Author$# $Date$# $Revision$#=========================================================================CMAKE_MINIMUM_REQUIRED(VERSION 2.4)IF(COMMAND cmake_policy) cmake_policy(SET CMP0003 NEW)ENDIF(COMMAND cmake_policy)PROJECT(VNL)FIND_PACKAGE(VXL) IF(VXL_FOUND) INCLUDE($&#123;VXL_CMAKE_DIR&#125;/UseVXL.cmake)ENDIF(VXL_FOUND)IF(WIN32)ADD_DEFINITIONS(-D_ALLOW_KEYWORD_MACROS)ENDIF(WIN32)#IF( VXL_VNL_FOUND ) INCLUDE_DIRECTORIES( $&#123;VXL_VNL_INCLUDE_DIR&#125; ) SET(IO_API_SRCS common.cpp ) file(GLOB_RECURSE IO_API_HDRS common.h ) ADD_LIBRARY(io_api $&#123;API_LIBRARY_TYPE&#125; $&#123;IO_API_SRCS&#125; $&#123;IO_API_HDRS&#125;)SET( VNL $&#123;VNL&#125; vnl_example.cpp )ADD_EXECUTABLE( VNL $&#123;VNL&#125;)TARGET_LINK_LIBRARIES( VNL io_api vnl_algo vnl vcl netlib) 其他库的调用跟上面的方法类似，如果不会也可以自行百度。 例如下面是打开openmp并行的编写： 1234567FIND_PACKAGE( OpenMP REQUIRED) if(OPENMP_FOUND) message("OPENMP FOUND") set(CMAKE_C_FLAGS "$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;") set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;") set(CMAKE_EXE_LINKER_FLAGS "$&#123;CMAKE_EXE_LINKER_FLAGS&#125; $&#123;OpenMP_EXE_LINKER_FLAGS&#125;") endif() 注：编写CMakelist的时候要注意一下各个的包含关系等，以及库的调用，还有名字等。]]></content>
      <tags>
        <tag>工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GPU监测时问题解决]]></title>
    <url>%2F2017%2F10%2F19%2FGPU%E7%9B%91%E6%B5%8B%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[GPU监测时问题解决不管在我们使用服务器还是使用自己的桌面版本的时候，跑程序时一方面，有时候我们会监测一下电脑的资源使用情况,但是监测的时候我们可以能会遇到一些问题。对于CPU资源的使用，我们可以使用top或者使用更高级的htop指令进行监测，这个里面包含了很多的信息。对于GPU资源的使用，我们一般使用nvidia-smi来进行一个监测，因为该指令是一个静态的，所以如果我们想动态的监测GPU的使用情况，我们可以配合watch指令进行使用，watch -n 1 nvidia-smi. 以上是我们使用一些基本方法，但是我在监测GPU的时候，可能会遇到以下两个问题： 1、GPU明明没有在用，但是显示的时候却显示GPU的利用率却很高，但是再看功率的时候又可以肯定GPU并没有在使用； 2、当一个用户用GPU跑完程序后，关掉了程序，但是GPU依旧显示该程序占用内存。 解决方法针对以上的两个问题，本人的解决方法如下 GPU监测时显示不准确对于GPU监测显示不准确时的指令如下：1sudo nvidia-smi -pm 1 GPU内存没有清零对于程序结束了，但是GPU内存没有被清零的情况，解决方案如下： 使用nvidia-smi指令进行查找没有释放内存的程序的PID；然后使用如下指令进行释放：1sudo kill -9 PID 参考资料https://serverfault.com/questions/809038/why-is-my-cuda-gpu-util-70-when-there-are-no-running-processes-found http://blog.csdn.net/lgh0824/article/details/77096241]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathjax 使用]]></title>
    <url>%2F2017%2F09%2F26%2Fmathjax%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}]]></content>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互信息]]></title>
    <url>%2F2017%2F09%2F17%2F%E4%BA%92%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[互信息在做医学图像分割时需要用到互信息来计算两幅图像的相似度。之前写好了函数，在此备份。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576float MI_hhl(float ***Img1, float ***Img2, int Image_X_Size, int Image_Y_Size, int Image_Z_Size)&#123; //绘制直方图 int Hist_Img1[256], Hist_Img2[256]; for (int t = 0; t &lt; 256; t++) &#123; Hist_Img1[t] = 0; Hist_Img2[t] = 0; &#125; for (int k = 0; k &lt; Image_Z_Size; k++) &#123; for (int i = 0; i &lt; Image_X_Size; i++) &#123; for (int j = 0; j&lt;Image_Y_Size; j++) &#123; Hist_Img1[(int)Img1[k][i][j]]++; Hist_Img2[(int)Img2[k][i][j]]++; &#125; &#125; &#125; //绘制两个图像的联合直方图 int Hist[256][256]; for (int i = 0; i &lt; 256; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; Hist[i][j] = 0; &#125; &#125; for (int k = 0; k &lt; Image_Z_Size; k++) &#123; for (int i = 0; i &lt; Image_X_Size; i++) &#123; for (int j = 0; j&lt;Image_Y_Size; j++) &#123; Hist[(int)Img1[k][i][j]][(int)Img2[k][i][j]]++; &#125; &#125; &#125; //计算单个概率 float P_Img1[256], P_Img2[256]; float all_number; all_number = Image_X_Size * Image_Y_Size * Image_Z_Size; for (int t = 0; t &lt; 256; t++) &#123; P_Img1[t] = (float)Hist_Img1[t] / all_number; P_Img2[t] = (float)Hist_Img2[t] / all_number; &#125; //计算联合概率 float P_Hist[256][256]; for (int i = 0; i &lt; 256; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; P_Hist[i][j] = (float)Hist[i][j] / all_number; &#125; &#125; //计算两个图像的互信息 float Mut_INF = 0; for (int i = 0; i &lt; 256; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; if (P_Hist[i][j] == 0 || P_Img1[i] == 0 || P_Img2[j] == 0) &#123; continue; &#125; Mut_INF += P_Hist[i][j] * log10(P_Hist[i][j] / (P_Img1[i] * P_Img2[j])); &#125; &#125; return Mut_INF;&#125;]]></content>
      <tags>
        <tag>医学图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于距离的计算方法]]></title>
    <url>%2F2017%2F09%2F17%2F%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基于距离的计算方法在因为之前项目中用到了欧氏距离，所以在网上看了一下，然后感觉还不错就转载到自己的笔记中。顺便测试了一下在博客中直接编写公式。 本文转自：http://blog.sina.com.cn/s/blog_52510b1d01015nrg.html 欧氏距离(Euclidean Distance)欧氏距离是最易于理解的一种距离计算方法，源自欧氏空间中两点间的距离公式。 (1)二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离： d_{12}=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(2)三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离： d_{12}=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}(3)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离： d_{12}=\sqrt{\sum_{k=1}^n(x_{1k}-x_{2k})^2}也可以用表示成向量运算的形式： d_{12}=\sqrt{(a-b)(a-b)^T}(4)Matlab计算欧氏距离 Matlab计算距离主要使用pdist函数。若X是一个M×N的矩阵，则pdist(X)将X矩阵M行的每一行作为一个N维向量，然后计算这M个向量两两间的距离。 例子：计算向量(0,0)、(1,0)、(0,2)两两间的欧式距离 X = [0 0 ; 1 0 ; 0 2] D = pdist(X,’euclidean’) 结果： D = 1.0000 2.0000 2.2361 曼哈顿距离(Manhattan Distance)从名字就可以猜出这种距离的计算方法了。想象你在曼哈顿要从一个十字路口开车到另外一个十字路口，驾驶距离是两点间的直线距离吗？显然不是，除非你能穿越大楼。实际驾驶距离就是这个“曼哈顿距离”。而这也是曼哈顿距离名称的来源， 曼哈顿距离也称为城市街区距离(City Block distance)。 (1)二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离 d_{12}=|x_1-x_2|+|y_1-y_2|(2)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离 d_{12}=\sum_{k=1}^n|x_{1k}-x_{2k}|(3) Matlab计算曼哈顿距离 例子：计算向量(0,0)、(1,0)、(0,2)两两间的曼哈顿距离 X = [0 0 ; 1 0 ; 0 2] D = pdist(X, ‘cityblock’) 结果： D = 1 2 3 标准化欧氏距离(Standardized Euclidean distance )(1)标准欧氏距离的定义 标准化欧氏距离是针对简单欧氏距离的缺点而作的一种改进方案。标准欧氏距离的思路：既然数据各维分量的分布不一样，好吧！那我先将各个分量都“标准化”到均值、方差相等吧。均值和方差标准化到多少呢？这里先复习点统计学知识吧，假设样本集X的均值(mean)为m，标准差(standard deviation)为s，那么X的“标准化变量”表示为： 而且标准化变量的数学期望为0，方差为1。因此样本集的标准化过程(standardization)用公式描述就是： X^* = \frac{X-m}{s}标准化后的值 = ( 标准化前的值 － 分量的均值 ) /分量的标准差 经过简单的推导就可以得到两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的标准化欧氏距离的公式： d_{12}=\sqrt{\sum_{k=1}^n(\frac{x_{1k}-x_{2k}}{s_k})^2}如果将方差的倒数看成是一个权重，这个公式可以看成是一种加权欧氏距离(Weighted Euclidean distance)。 (2)Matlab计算标准化欧氏距离 例子：计算向量(0,0)、(1,0)、(0,2)两两间的标准化欧氏距离 (假设两个分量的标准差分别为0.5和1) X = [0 0 ; 1 0 ; 0 2] D = pdist(X, ‘seuclidean’,[0.5,1]) 结果： D = 2.0000 2.0000 2.8284 夹角余弦(Cosine)有没有搞错，又不是学几何，怎么扯到夹角余弦了？各位看官稍安勿躁。几何中夹角余弦可用来衡量两个向量方向的差异，机器学习中借用这一概念来衡量样本向量之间的差异。 (1)在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式： \cos \theta = \frac{x_1x_2+y_1y_2}{\sqrt{x_1^2+y_1^2} \sqrt{x_2^2+y_2^2}}(2) 两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦 类似的，对于两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)，可以使用类似于夹角余弦的概念来衡量它们间的相似程度。 \cos(\theta)=\frac{a \cdot b}{|a||b|}即： \cos(\theta)=\frac{\sum_{k=1}^n x_{1k}x_{2k}}{\sqrt{\sum_{k=1}^nx_{1k}^2}\sqrt{\sum_{k=1}^nx_{2k}^2}}夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。 (3)Matlab计算夹角余弦 例子：计算(1,0)、( 1,1.732)、( -1,0)两两间的夹角余弦 X = [1 0 ; 1 1.732 ; -1 0] D = 1- pdist(X, ‘cosine’) % Matlab中的pdist(X, ‘cosine’)得到的是1减夹角余弦的值 结果： D = 0.5000 -1.0000 -0.5000]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh连接服务器中断，如何让命令继续在服务器执行]]></title>
    <url>%2F2017%2F09%2F08%2Fssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%91%BD%E4%BB%A4%E7%BB%A7%E7%BB%AD%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[ssh连接linux服务器中断后，如何让命令继续在服务器运行这个问题也许是我们这些小白比较头疼的问题，尤其对于那些做机器学习需要花很久的时间才能训练出一个结果。然而就在这时，因为各种不可抗力我们使用ssh连接服务器时，ssh的窗口突然断开了连接，那么在服务器上跑的程序就也跟着断掉了，之前所有跑的数据也将丢失，这样将会浪费我们大量的时间。 今天刚好有人跟我提到了这个问题，然后就简单上网查找资料，简单的学习一下，做个笔记方便自己以后查阅。 参考链接： http://blog.csdn.net/gukesdo/article/details/6901902 为什么ssh一旦断开我们的进程也将会被杀掉？元凶：SIGHUP 信号 让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。 在Linux/Unix中，有这样几个概念： 进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。 会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。 会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。 根据POSIX.1定义： 挂断信号（SIGHUP）默认的动作是终止程序。 当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。 如果会话期首进程终止，则该信号发送到该会话期前台进程组。 一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。 因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。 这里我认为我们的进程被杀掉也就是因为ssh与服务器之间的通信断掉了，这个通信断掉之后linux程序就默认将该连接下的所有进程都杀掉 解决方案针对上面的问题，上面的参考链接中也有讲解，在此进行一个简单的整理。 这里主要有三个方案，一个是使用nohup指令，一个是使用screen指令，最后一个是screen的升级版byobu。看完这三个指令之后其实我更倾向于使用byobu指令，因为byobu指令更加的强大,是screen的升级版本，并且界面也比较友好。 nohup命令nohup命令参考 nohup 命令 用途：不挂断地运行命令。 语法：nohup Command [ Arg … ] [ &amp; ] 描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断(SIGHUP)信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; ( 表示”and”的符号)到命令的尾部。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 nohup的简单使用在执行命令时在命令前面加上nohup，然后回车开始运行。 这时你会发现该有的输出其实并没有输出出来，这个时候不要方，这是因为nohup命令将你的所有输出都输出到了当前文件夹下的nohup.out文件中，自己可以使用vim指令进行一个查看。 nohup命令及其输出文件 nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。 该命令的一般形式为：nohup command &amp; 使用nohup命令提交作业 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： nohup command &gt; myout.file 2&gt;&amp;1 &amp; 使用 jobs 查看任务。 使用 fg %n 关闭。 screen命令简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在screen中创建一个新的窗口有这样几种方式： 1．直接在命令行键入screen命令 $ screenScreen将创建一个执行shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。 2．Screen命令后跟你要执行的程序。 $ screen 【后面跟你执行程序的命令】 Screen创建一个执行vi test.c的单窗口会话，退出vi将退出该窗口/会话。 3．以上两种方式都创建新的screen会话。我们还可以在一个已有screen会话中创建新的窗口。在当前screen窗口中键入C-a c ，即Ctrl键+a键，之后再按下c键，screen 在该会话内生成一个新的窗口并切换到该窗口。 screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。 screen的简单使用在所要执行的指令前添加screen.然后程序的运行等一切正常。（nohup的输出是定向到了nohup.out文件中，然而screen指令的输出是直接输出到了屏幕上的） 这个时候如果ssh终端断开了连接。我们只需要再次连接服务器然后输入指令 1screen -ls 然后会得到类似下面的结果： 123There is a screen on: 27267.pts-19.TITAN-X (09/08/2017 03:49:10 PM) (Detached)1 Socket in /var/run/screen/S-huanghailiang. 这里就会显示ssh断开之前的程序，其实断开后程序依然在后台在运行，只是我们这个时候需要将它放到前台来运行。这个时候我们们已经通过screen -ls查询到了线程号是27267了，所以我们只需要执行下面的指令即可恢复到前台了。 1screen -r 27267 如果想杀掉终端可以执行 1kill 27267 其他更多的指令可以通过screen —help来进行学习。 当然screen还有更多的快捷键值得我们学习。我们可以通过C-a ? 即先按ctrl+a以后再按？即可查看。 通过观察我们可以发现它其实恢复了我们ssh断开前的那个界面。（所有的输出也都会在此显示出来） byobu命令byobu感觉就是screen的一个升级版本，界面比较友好，操作也比较方便。一般Ubuntu系统开始的时候默认没有安装，我们需要手动安装byobu: 1sudo apt install byobu byobu的基本简单操作 按键 说明 F2 新建窗口 F3 移动到前一个窗口 F4 移动到后一个窗口 F6 退出byobu窗口 F9 打开byobu菜单，查看帮助信息的配置信息 关闭当前窗口其实Ctrl+D就可以完成 剩余操作我们可以F9查看byobu的帮助即可。 如果我们想要一登陆就显示byobu界面的话，可以使用指令1byobu-enable 如果想取消一登陆就显示byobu界面可以是用指令1byobu-disable 注（个人理解）：nohup虽然可以把所有的输出都写入到nohup.out中间来，但是在面对需要人机交互的时候它就不能正常使用了。另外在我做测试的时候，一旦ssh断开，虽然程序还在后台运行，但是好像并不会再把输出写入到nohup.out文件中，这一点很不好。 screen相比之下就强大了很多，不仅可以满足人机交互，而且还可以将所有的输出都再次展示出来，方便我们查看。我对screen的理解是，其实它是一个虚拟的终端，我们运行的时候screen指令就为我们创建了一个虚拟的终端，所以我们再次连接后我们打开的还是这个虚拟的终端，所以我们可以更好的进行操作，而且screen支持开很多个终端。 byobu相比之下继承了screen的所有优点，并且拥有了更加方便快捷的操作界面，同时在界面下方还能很好的显示目前计算机的硬件使用情况，十分方便。 它们三者的共性我认为都已经不受SIGHUP信号的影响了，所以即使断掉了ssh程序依旧会运行。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速哈达玛变换]]></title>
    <url>%2F2017%2F09%2F06%2F%E5%BF%AB%E9%80%9F%E5%93%88%E8%BE%BE%E7%8E%9B%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[快速哈达玛变换在生成哈达玛矩阵的文章中我已经提到了沃尔什函数，其实也就是快速哈达玛变换，他是针对与压缩感知中压缩过程中对哈达玛矩阵的行进行一个变换，这么做可以更好的压缩图像，并更好的进行解压。 快速哈达玛矩阵的代码实现简单的实现就是写成二进制表示没然后保存反向格雷码就是新矩阵所对应的行号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define M 128int num = 1; //需要转换的数int number = 0;int Gray_number(int num_h)&#123; int binary[30];//保存反向二进制的值 int Gray[30];//保存反向格雷码 //////////////////// int M_m = M - 1; int M_num = 0; while (1) &#123; M_m = M_m / 2; M_num++; printf("M_num=%d", M_num); if (M_m == 0) &#123; break; &#125; &#125; //////////////////// printf("num_h=%d", num_h); printf("\n"); int i = 0; while (1) &#123; binary[i] = num_h % 2; printf("\ni=%d binary[i]=%d\n", i, binary[i]); num_h = num_h / 2; i++; if (num_h == 0) &#123; break; &#125; &#125; /////////////// printf("\ni=%d\n", i); for (i = i; i&lt;M_num; i++) &#123; binary[i] = 0; printf("\ni=%d binary[i]=%d\n", i, binary[i]); &#125; //////////// int j = 0; for (j = 0; j&lt;i; j++) &#123; printf("binary[j]=%d %d\n", binary[j], j); &#125; printf("\n%d", i); //得到反向的格雷码 int k = 0, Gray_num = 0; for (k = 0; k&lt;i - 1; k++) &#123; if ((binary[k] - binary[k + 1]) == 0) &#123; Gray_num = 0; &#125; else &#123; Gray_num = 1; &#125; Gray[k] = Gray_num; &#125; Gray[i - 1] = binary[i - 1]; printf("\nGray\n", i); for (j = 0; j&lt;i; j++) &#123; printf("%d", Gray[j]); &#125; printf("\nlast number\n", i); for (j = 0; j&lt;i; j++) &#123; number += Gray[j] * pow((double)2, (int)(i - j - 1)); &#125; printf("number=%d", number); printf("\n"); return number;&#125;int main()&#123; Gray_number(num); printf("\n"); printf("\n"); printf("\n"); printf("number=%d", number);&#125;]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成哈达玛矩阵]]></title>
    <url>%2F2017%2F09%2F06%2F%E7%94%9F%E6%88%90%E5%93%88%E8%BE%BE%E7%8E%9B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[哈达玛矩阵是什么哈达玛（Hadamard)矩阵是由+1和-1元素构成的正交方阵。所谓正交方阵，指它的任意两行（或两列）都是正交的，且任意一行（列）的所有元素的平方和等于方阵的阶数。即：设A为n阶由+1和-1元素构成的方阵，若AA‘=nI（这里A’为A的转置，I为单位方阵），则称A为n阶Hadamard矩阵。 已有人证明，Hadamard矩阵的阶数都是4的倍数。 哈达玛矩阵的应用本人使用哈达玛矩阵是在压缩感知中知道的，在压缩中进行快速哈达玛变换（沃尔什函数）的变换以后就可以进行图像压缩，之后在运用TVAL3算法就可以进行一个解压缩，来还原原来的图像。现在的压缩比基本都在10%之下。 哈达玛矩阵生成的代码这里的M和N表示矩阵的大小。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#define M 32 #define N 32int Hadamard[M][N];//生成哈达玛矩阵的函数int CreateHadmard(int i, int j)&#123; long k, temp, result = 0; temp = i&amp;j; for (k = 0; k&lt;32; k++) &#123; result = result + (temp &gt;&gt; k) &amp; 1; &#125; if (result % 2 == 0) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;int main()&#123; int i, j; printf("生成哈达玛矩阵\n"); for (i = 0; i&lt;M; i++) &#123; for (j = 0; j&lt;N; j++) &#123; Hadamard[i][j] = CreateHadmard(i, j); printf("%3d", Hadamard[i][j]); &#125; printf("\n"); &#125;&#125;]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言读取系统当前时间]]></title>
    <url>%2F2017%2F09%2F06%2FC%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[C语言读取系统当前时间之前编程的时候我们需要来读取当前的时间，或者使用当前的时间对文件进行一个命名等，所以做一个笔记用来备忘。 读取时间代码C语言读取系统时间的代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main()&#123; time_t timep,Tim; struct tm *p; time(&amp;timep); p = localtime(&amp;timep); //此函数获得的tm结构体的时间，是已经进行过时区转化为本地时间 //p = gmtime(&amp;timep); //把日期和时间转换为格林威治(GMT)时间的函数 int Year = 1900 + p-&gt;tm_year; int Month = 1 + p-&gt;tm_mon; int Day = p-&gt;tm_mday; int Hour = p-&gt;tm_hour; int Minute = p-&gt;tm_min; int Second = p-&gt;tm_sec; char year[20]; char month[20]; char day[20]; char hour[20]; char minute[20]; char second[20]; printf("year=%d\n",Year); printf("month=%d\n", Month); printf("day=%d\n", Day); printf("hour=%d\n", Hour); printf("minute=%d\n", Minute); printf("second=%d\n", Second); return 0; &#125; 以上为简单的系统时间读取。在Windows环境下好像运行是有问题的，这个时候需要在预编译头那里添加 _CRT_SECURE_NO_WARNINGS即可。 localtime函数获得的tm结构体的时间，是已经进行过时区转化为本地时间，然而gmtime函数是把日期和时间转换为格林威治(GMT)时间的函数。 要用这个时间对文件进行命名在我们进行编程的时候有时候需要对文件进行命名，有时候一个程序是不停的循环运行的，我们还要区分程序跑出来的文件结果，所以这个时候我们如果使用时间来对文件命名的话就会方便很多，而且一定不会因为重名而被覆盖。 这个时候我们可以用sprintf和strcat这两个函数进行一个组合。简单的例子如下： 123456789101112131415161718192021 char name[100] = "1616_";char year[20];char month[20];char day[20];char hour[20];char minute[20];char second[20];char txt[5] = ".txt"; sprintf(year, "%d", Year);sprintf(month, "%d", Month);sprintf(day, "%d", Day);sprintf(hour, "%d", Hour);sprintf(minute, "%d", Minute);sprintf(second, "%d", Second);strcat(name, year);strcat(name, month);strcat(name, day);strcat(name, hour);strcat(name, minute);strcat(name, second);strcat(name, txt);]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用C语言自己写2048]]></title>
    <url>%2F2017%2F09%2F05%2F2048%2F</url>
    <content type="text"><![CDATA[用C语言自己写20482048是之前非常火爆的一个游戏，记得之前上课的时候很多同学都在玩这个游戏。尤其是一些比较无聊的课上玩的人更多。那么我们应该如何用代码自己来实现2048这个游戏的编写呢？ 之前在实验楼网站学习linux的时候碰巧看到了一个教程，所以就试着玩了一下，代码编写也很简单，当然我也无聊的玩到了2048，所以我发现其实实验楼上面给的代码也是有点小bug的，所以我对代码进行了一个简单的更改。 实验楼该教程网址： https://www.shiyanlou.com/courses/155 下面就是操作及其我修改后的代码： 基础知识要实现我们的 2048 小游戏，需要涉及一些数据结构的知识，以及一些 Linux 的系统调用。此外，为了方便在屏幕上使用字符绘图，我们还需要使用一个文本界面的屏幕绘图库 ncurses ，具体到操作就是在编译的时候需要加上 -lcurses 选项。 ncurses 库的安装操作如下：1sudo apt-get install libncurses5-dev 我修改后的代码创建一个c文件，命名为2048.c 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;curses.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;// 4*4方格int a[4][4] = &#123;0&#125;;// 方格里空格的个数int empty;int old_y, old_x;void draw();void play();void init();void draw_one(int y, int x);void cnt_value(int *new_y, int *new_x);int game_over();int cnt_one(int y, int x);int main()&#123; init(); play(); endwin(); return 0;&#125;void init()&#123; int x, y; initscr(); cbreak(); noecho(); curs_set(0); empty = 15; srand(time(0)); x = rand() % 4; y = rand() % 4; a[y][x] = 2; draw();&#125;void draw()&#123; int n, m, x, y; char c[4] = &#123;'0', '0', '0', '0'&#125;; clear(); for(n = 0; n &lt; 9; n += 2) //横线 for(m = 0; m &lt; 21; m++) &#123; move(n, m); addch('-'); refresh(); &#125; for(m = 0; m &lt; 22; m += 5) //竖线 for(n = 1; n &lt; 8; n++) &#123; move(n, m); addch('|'); refresh(); &#125; for(y = 0; y &lt; 4; y++) //数字 for(x = 0; x &lt; 4; x++) &#123; draw_one(y, x); &#125;&#125;void draw_one(int y, int x)&#123; int i, m, k, j; char c[4] = &#123;'0', '0', '0', '0'&#125;; i = a[y][x]; m = 0; do &#123; j = i % 10; c[m++] = j + '0'; i = i / 10; &#125;while(i &gt; 0); m = 0; k = (x + 1) * 5 - 1; while(c[m] != '0') &#123; move(2*y+1, k); addch(c[m++]); k--; &#125;&#125;void play()&#123; int x, y, i, new_x, new_y, tmp; int old_empty, move; char ch; while(1) &#123; move = 0; old_empty = empty; //draw(); ch = getch(); switch(ch) &#123; case 'A': case 'a': //从左向右消去相同方块 for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; ) &#123; if(a[y][x] == 0) &#123; x++; continue; &#125; else &#123; for(i = x + 1; i &lt; 4; i++) &#123; if(a[y][i] == 0) &#123; continue; &#125; else &#123; if(a[y][x] == a[y][i]) &#123; a[y][x] += a[y][i]; a[y][i] = 0; x = i + 1; empty++; break; &#125; else &#123; x = i; break; &#125; &#125; &#125; x = i; &#125; &#125; //向左移动方块 for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; x++) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = x; (i &gt; 0) &amp;&amp; (a[y][i-1] == 0); i--) &#123; a[y][i-1] = a[y][i]; a[y][i] = 0; move = 1; &#125; &#125; &#125; break; case 'D': case 'd': //从右向左消去相同方块 for(y = 0; y &lt; 4; y++) for(x = 3; x &gt;= 0; ) &#123; if(a[y][x] == 0) &#123; x--; continue; &#125; else &#123; for(i = x - 1; i &gt;= 0; i--) &#123; if(a[y][i] == 0) &#123; continue; &#125; else if(a[y][x] == a[y][i]) &#123; a[y][x] += a[y][i]; a[y][i] = 0; x = i - 1; empty++; break; &#125; else &#123; x = i; break; &#125; &#125; x = i; &#125; &#125; //向右移动方块 for(y = 0; y &lt; 4; y++) for(x = 3; x &gt;= 0; x--) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = x; (i &lt; 3) &amp;&amp; (a[y][i+1] == 0); i++) &#123; a[y][i+1] = a[y][i]; a[y][i] = 0; move = 1; &#125; &#125; &#125; break; case 'W': case 'w': //从上向下消去相同方块 for(x = 0; x &lt; 4; x++) for(y = 0; y &lt; 4; ) &#123; if(a[y][x] == 0) &#123; y++; continue; &#125; else &#123; for(i = y + 1; i &lt; 4; i++) &#123; if(a[i][x] == 0) &#123; continue; &#125; else if(a[y][x] == a[i][x]) &#123; a[y][x] += a[i][x]; a[i][x] = 0; y = i + 1; empty++; break; &#125; else &#123; y = i; break; &#125; &#125; y = i; &#125; &#125; //向上移动方块 for(x = 0; x &lt; 4; x++) for(y = 0; y &lt; 4; y++) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = y; (i &gt; 0) &amp;&amp; (a[i-1][x] == 0); i--) &#123; a[i-1][x] = a[i][x]; a[i][x] = 0; move = 1; &#125; &#125; &#125; break; case 'S': case 's': //从下向上消去相同方块 for(x = 0; x &lt; 4; x++) for(y = 3; y &gt;= 0; ) &#123; if(a[y][x] == 0) &#123; y--; continue; &#125; else &#123; for(i = y - 1; i &gt;= 0; i--) &#123; if(a[i][x] == 0) &#123; continue; &#125; else if(a[y][x] == a[i][x]) &#123; a[y][x] += a[i][x]; a[i][x] = 0; y = i -1; empty++; break; &#125; else &#123; y = i; break; &#125; &#125; y = i; &#125; &#125; //向下移动方块 for(x = 0; x &lt; 4; x++) for(y = 3; y &gt;= 0; y--) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = y; (i &lt; 3) &amp;&amp; (a[i+1][x] == 0); i++) &#123; a[i+1][x] = a[i][x]; a[i][x] = 0; move = 1; &#125; &#125; &#125; break; case 'Q': case 'q': game_over(); break; default: continue; break; &#125; if(empty &lt;= 0) game_over(); draw(); //生成新方块 if((empty != old_empty) || (move == 1)) &#123; //修复了不移动或消除方块也生成新方块的bug do &#123; new_x = rand() % 4; new_y = rand() % 4; &#125;while(a[new_y][new_x] != 0); cnt_value(&amp;new_y, &amp;new_x); do &#123; tmp = rand() % 4; &#125;while(tmp == 0 || tmp == 2); a[new_y][new_x] = tmp + 1; empty--; draw_one(new_y, new_x); &#125; &#125;&#125;int cnt_one(int y, int x)&#123; int value = 1; if(y - 1 &gt; 0) a[y-1][x] ? 0 : value++; if(y + 1 &lt; 4) a[y+1][x] ? 0 : value++; if(x - 1 &gt;= 0) a[y][x-1] ? 0 : value++; if(x + 1 &lt; 4) a[y][x+1] ? 0 : value++; if(y - 1 &gt;= 0 &amp;&amp; x - 1 &gt;= 0) a[y-1][x-1] ? 0 : value++; if(y - 1 &gt;= 0 &amp;&amp; x + 1 &lt; 4) a[y-1][x+1] ? 0 : value++; if(y + 1 &lt; 4 &amp;&amp; x - 1 &gt;= 0) a[y+1][x-1] ? 0 : value++; if(y + 1 &lt; 4 &amp;&amp; x + 1 &lt; 4) a[y+1][x+1] ? 0 : value++; return value;&#125;void cnt_value(int *new_y, int *new_x)&#123; int max_x, max_y, x, y, value; int max = 0; max = cnt_one(*new_y, *new_x); for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; x++) &#123; if(!a[y][x]) &#123; value = cnt_one(y, x); if(value &gt; max &amp;&amp; old_y != y &amp;&amp; old_x != x) &#123; //避免在同一位置反复出现新方块 *new_y = y; *new_x = x; old_x = x; old_y = y; break; &#125; &#125; &#125;&#125;int game_over()&#123; sleep(1); endwin(); exit(0);&#125; 编译程序1gcc 2048.c -o 2048 -lcurses 运行程序1./2048 操作使用“w”;”a”;”s”;”d”;或者”W”;”A”;”S”;”D”来进行移动 效果图如下：]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu server 硬盘挂载教程]]></title>
    <url>%2F2017%2F09%2F05%2FUbuntu-server-%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Ubuntu server 硬盘挂载教程在我们使用服务器的时候，因为使用的人比较多，而且目前做机器学习的人比较多，然而机器学习那边需要训练一些数据，训练集比较大，这就对于我们服务器的存储能力是一个较大的体验，所以一块硬盘已经不能满足我们的需求，我们需要使用多块硬盘来一起存储我们的数据，但是Ubuntu系统要识别多块硬盘需要我们自己配置。 本人认为有以下几种方法： 1、在安装Ubuntu系统的时候，我们可以手动配置挂载。（这个我们有尝试过，不过理论上应该是可以实现的，不过我们一般比较懒，所以会选择自动分配，这样我们比较省事。然而自动分配的话，系统会让你自己选择一个空硬盘或者一个连续的没有用的磁盘空间进行。） 2、设置磁盘阵列（比如raid），这个好像也是要在安装系统前进行。简单来说就是将多块磁盘的逻辑分区方放到一起来当作一块使用。（不知道这样的理解对不对，不过呢，个人感觉实际效果就是这个样子的）然后再正常安装选择硬盘的时候你会发现有一个很大的硬盘。（当然这种方法可能也有一些限制，比如两块硬盘的大小要一样等要求，需要自己去找）。 如果系统已经装好了，我们要用上面的两种方法我觉得很不现实的，所以有些时候我们需要另想办法的。 3、可以使用LVM技术来创建逻辑分区，这个我在网上看到过，网址如下，感觉讲的还是比较详细的。 参考网址：http://blog.csdn.net/it_yuan/article/details/19242445 4、可以直接使用硬盘进行挂载。（也试用于优盘的挂载，不过是服务器版本，一般我们自己用的桌面版本好像它会自动加载优盘的，服务器版本需要自己手动设置的） 参考网址：http://zwkufo.blog.163.com/blog/static/258825120141283942244/ 由于前3种方法我没有亲自尝试，所以这里暂时先不说了，不过网上教程也有的，后面如果有机会的话，我可能会补充进来。所以这里我就简单说一些第四种方法好了。 硬盘挂载 1、 sudo fdisk –lu (查看当前硬盘及分区情况) 可以看到类似界面 2、 sudo fdisk /dev/sdb(这里为想要挂载的硬盘名称)，利用该命令可以对硬盘进行分区，具体可以参考网址中的讲解更加详细 3、 sudo mkfs –t ext4 /dev/sdb(硬盘格式化，-t ext4 表示将分区格式化成ext4文件系统类型) 4、 sudo df –l(显示硬盘挂载情况) sudo mount –t ext4 /dev/sdb(想要挂载的硬盘) /devdata(目标挂载点) 结束后可以用sudo df –l 查看是否成功 5、 配置系统启动自动挂载，修改/etc/fstab文件，添加 /devdata was on /dev/sdb UUID=37eaa526-5d96-4237-8468-603df5216ce9 /devdata(挂载点) ext4 defaults 0 0 UUID通过sudo blkid 可以查看 其实好像输入/dev/sdb也是可以的，例如我在实验室服务器上面的挂载如下：]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git本地库的建立与使用]]></title>
    <url>%2F2017%2F09%2F03%2FGit%E6%9C%AC%E5%9C%B0%E5%BA%93%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git本地库的建立与使用本笔记是自己在网上学习后整理后得到的，主要针对的是本地库的建立以及使用，对于远程库的操作这里暂时不涉及。 本教程的本地库的建立主要是在linux系统上建立，windows上可以使用命令行的git bash 或者带有图形界面的TortoiseGit进行操作，有兴趣的话可以自己学习一下。 在linux版本上：1、打开终端输入git，如果没有安装，按照提示指令进行安装。例如：sudo apt-get install git。如果已经安装会有如下显示 2、Git的配置设置你的名字和email,就是你提交commit时的签名，每次提交记录里面都会包含这些信息。使用git config命令进行设置。 执行后会在根目录下建立一个叫.gitconfig的文件（该文件为隐藏文件需要使用ls -la查看到） 其中隐藏文件.gitconfig的内容可以使用vim或者cat进行查看 3、获取一个Git仓库，这里有两种方法，一种是直接clone一个仓库，另一个是初始化一个仓库。这里我们可以直接自己初始化一个仓库，当然clone仓库也是比较简单的，自己看一下就好。首先需要自己创建一个仓库文件夹，路径什么的自己选择就好，创建使用mkdir就好。例如：mkdir project 就是创建了一个叫project的文件。这里我之前自己手动建立好了一个文件夹就直接使用cd命令进去就好了。初始化Git仓库使用git init命令，Git输出如下。 使用ls -la 可以看出来有一个.git目录被创建，意味着仓库被初始化。 4、git仓库已经被创建好了，接下来就是一些基本操作了。 基本流程：（1）、创建或者修改文件（2）、使用git add命令添加新创建或修改的文件到本地的缓存区（Index）。使用的时候是git add &lt;文件名&gt;或者git add 这说明添加当前文件夹下的所有文件。 （3）、使用git commit命令提交到本地代码库。git commit -m “双引号中间是你们提交代码时写的备注” 使用-m的目的是为了添加本次修改的注释，完成后就会记录一个新的版本。除了用git add命令，我们还可以使用git commit -a -m “双引号中间是你们提交代码时写的备注” 将所有没有加入到缓存区的修改也一起提交，但是 -a命令不能添加新建文件。 （4）（这一步我们的工程不需要，因为我们不需要同步到远程的代码库，因为同步到远程的代码库后相当于开源给了所有人,但是后期你们自己使用git的时候是可以使用的）使用git push命令将本地代码库同步到远端代码库。 git status命令查看当前git仓库的状态。 git commit提交了本地代码库以后，可以是使用git diff 命令再加上 —cached参数，看看缓存区中哪些文件被修改了。进入到git diff —cached界面后需要输入q才可以退出。如果没有 —cached参数，git diff会显示当前你所有已经做的但是没有加入到索引里的修改。所有修改完了以后都需要按照上面的步骤加上缓存区，在用commit提交到本地库。 注：如果是修改文件，也需要使用git add命令添加到缓存区才可以提交。如果是删除文件，则直接使用git rm命令删除后悔自动将已删除文件的信息添加到缓存区，git commit提交后会将本地仓库中的对应文件删除。（【这一步我们不使用】如果本地仓库链接到了远程Git服务器，可以使用git push origin master 命令将本地仓库同步到远端服务器）。 5、git的基本操作以及介绍完了。但是基本都是个人操作的，下面介绍一下如果团队合作的话，每个人写一部分代码，最终合并的话，我们需要使用分支与合并的知识。 （1）、分支 使用 git branch &lt;分支名&gt;来创建分支。这里我将为大家每个人创建一个分支，分支名的命名方式我将使用*表示目前所在的分支。Master是默认的主分支。 使用git checkout &lt;分支名&gt;来选择切换分支，例如下面我将会切换成我自己的分支：由图可以看到*已经跑到了hhl前面说明现在的分支是hhl。 切换到自己的分支以后可以自己更改自己的程序，这样并不会影响到其他分支的程序。 （2）、合并 可以使用git merge命令来进行合并。例如想合并hhl分支到主分支，则需要先切换到主分支上git checkout master 然后再将hhl分支合并到主分支中，git merge -m “这里双引号里面依旧是注释” hhl -m参数仍然是填写合并的注释信息。 注：如果如果两个想要合并的分支都对同一个文件进行了修改，则在合并的时候会有冲突。这个地方需要我们使用vim编辑器手动解决冲突，然后再add再commit提交。 （【这一步也不需要，后期自己使用可以先了解一下】，合并完分支后，如果想删除分支的话使用 git branch -d &lt;分支名&gt;，这个只针对已经被当前分支合并了的分支，如果你想要前置删除某个分支的话使用 git branch -D &lt;分支名&gt;） 撤销合并：如果合并完以后，想要把当前修改都放弃，可以使用 git reset —hard HEAD^ 进行撤销合并。 6、查看日志 git log 命令可以显示所有的提交。如果提交的历史纪录很长，回车会逐步显示，输入q可以退出。 如果用git log —stat 它会显示在每个提交（commit）中哪些文件被修改，这些文件分别添加或删除多少行内容，这个命令相当于打印详细的提交记录。 小结，基本指令： （1）git config :配置相关信息 （2）git clone ：复制仓库 （3）git init :初始化仓库 （4）git add ：添加更新内容到 （5）git diff :比较内容 （6）git status :获取当前项目状况 （7）git commit :提交 （8）git branch :分支相关 （9）git checkout :切换分支 （10）git merge :合并分支 （11）git reset :恢复版本 （12）git log :查看日志]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片转换成字符图]]></title>
    <url>%2F2017%2F09%2F02%2F%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图片转换成字符图因为之前写到了一些好玩的注释模板，当然网上有很多很多好玩的图片，我们不可能完全收集过来，当然也不可能正好有你自己所需要的图片，所以我们需要一个自己将图片转换成字符图的一个代码，这样我们就可以很方便的得到自己想得到的一些字符图。 参考网址实验楼有该教程，个人觉得不错，还给了源码，所以摘抄代码下来学习https://www.shiyanlou.com/courses/370 python实现源码编写ascii.py源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#-*- coding:utf-8 -*-from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.output#这里的list可以自己定义ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = "" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\n' print txt #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 代码的运行1python ascii.py ascii_dora.png 根据实验楼的效果展示原图 效果图]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释模板（仅供娱乐）]]></title>
    <url>%2F2017%2F09%2F02%2F%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%BB%85%E4%BE%9B%E5%A8%B1%E4%B9%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注释模板（仅供娱乐）今天无意间在网上看到了一些好玩的注释，让我想起之前开始写代码的时候就已经有人开始在代码中添加这些东西，感觉挺好玩的，随手摘抄，仅供娱乐。 参考网址http://blog.csdn.net/ouyang_peng/article/details/51803181http://www.oschina.net/code/snippet_1046345_43901 在VS中直接设置注释模板因为我只是觉得好玩，所以摘抄一下，具体设置可以参照上面第一个参考网址进行设置。 佛祖保佑 永无bug12345678910111213141516171819202122232425262728293031/** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ____/`---'\____ * .' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ * 佛祖保佑 永无BUG * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？*/ 12345678910111213141516171819202122////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88" . "88 //// (| ^_^ |) //// O\ = /O //// ____/`---'\____ //// .' \\| |// `. //// / \\||| : |||// \ //// / _||||| -:- |||||- \ //// | | \\\ - /// | | //// | \_| ''\---/'' | | //// \ .-\__ `-` ___/-. / //// ___`. .' /--.--\ `. . ___ //// ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". //// | | : `- \`.;`\ _ /`;.`/ - ` : | | //// \ \ `-. \_ __\ /__ _/ .-` / / //// ========`-.____`-.___\_____/___.-`____.-'======== //// `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永无BUG 永不修改 ////////////////////////////////////////////////////////////////////// 神兽保佑 代码无BUG！1234567891011121314151617// ┏┓ ┏┓// ┏┛┻━━━┛┻┓// ┃ ┃ // ┃ ━ ┃// ┃ ┳┛ ┗┳ ┃// ┃ ┃// ┃ ┻ ┃// ┃ ┃// ┗━┓ ┏━┛// ┃ ┃ 神兽保佑 // ┃ ┃ 代码无BUG！// ┃ ┗━━━┓// ┃ ┣┓// ┃ ┏┛// ┗┓┓┏━┳┓┏┛// ┃┫┫ ┃┫┫// ┗┻┛ ┗┻┛ 1234567891011121314151617181920212223/** * * ━━━━━━神兽出没━━━━━━ * ┏┓ ┏┓ * ┏┛┻━━━┛┻┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ┳┛ ┗┳ ┃ * ┃ ┃ * ┃ ┻ ┃ * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ * * ━━━━━━感觉萌萌哒━━━━━━ */ 1234567891011121314151617181920212223/** * ┏┓ ┏┓ * ┏┛┻━━━┛┻┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */ 1234567891011121314151617181920212223/** * ┏┓ ┏┓+ + * ┏┛┻━━━┛┻┓ + + * ┃ ┃ * ┃ ━ ┃ ++ + + + * ████━████ ┃+ * ┃ ┃ + * ┃ ┻ ┃ * ┃ ┃ + + * ┗━┓ ┏━┛ * ┃ ┃ * ┃ ┃ + + + + * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ + * ┃ ┗━━━┓ + + * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ + + + + * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛+ + + + */ 程序员之歌1234567891011/** * 江城子 . 程序员之歌 * * 十年生死两茫茫，写程序，到天亮。 * 千行代码，Bug何处藏。 * 纵使上线又怎样，朝令改，夕断肠。 * * 领导每天新想法，天天改，日日忙。 * 相顾无言，惟有泪千行。 * 每晚灯火阑珊处，夜难寐，加班狂。*/ 其他好玩的图片1234567891011121314151617/********************************************************************** .--, .--, ( ( \.---./ ) ) '.__/o o\__.' &#123;= ^ =&#125; &gt; - &lt; / \ // \\ //| . |\\ "'\ /'"_.-~^`'-. \ _ /--' ` ___)( )(___ (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。**********************************************************************/ 1234567891011121314151617181920212223242526272829303132333435/********************************************************************** :: :;J7, :, ::;7: ,ivYi, , ;LLLFS: :iv7Yi :7ri;j5PL ,:ivYLvr ,ivrrirrY2X, :;r@Wwz.7r: :ivu@kexianli. :iL7::,:::iiirii:ii;::::,,irvF7rvvLujL7ur ri::,:,::i:iiiiiii:i:irrv177JX7rYXqZEkvv17 ;i:, , ::::iirrririi:i:::iiir2XXvii;L8OGJr71i :,, ,,: ,::ir@mingyi.irii:i:::j1jri7ZBOS7ivv, ,::, ::rv77iiiriii:iii:i::,rvLq@huhao.Li ,, ,, ,:ir7ir::,:::i;ir:::i:i::rSGGYri712: ::: ,v7r:: ::rrv77:, ,, ,:i7rrii:::::, ir7ri7Lri , 2OBBOi,iiir;r:: ,irriiii::,, ,iv7Luur: ,, i78MBBi,:,:::,:, :7FSL: ,iriii:::i::,,:rLqXv:: : iuMMP: :,:::,:ii;2GY7OBB0viiii:i:iii:i:::iJqL;:: , ::::i ,,,,, ::LuBBu BBBBBErii:i:i:i:i:i:i:r77ii , : , ,,:::rruBZ1MBBqi, :,,,:::,::::::iiriri: , ,,,,::::i: @arqiao. ,:,, ,:::ii;i7: :, rjujLYLi ,,:::::,:::::::::,, ,:i,:,,,,,::i:iii :: BBBBBBBBB0, ,,::: , ,:::::: , ,,,, ,,::::::: i, , ,8BMMBBBBBBi ,,:,, ,,, , , , , , :,::ii::i:: : iZMOMOMBBM2::::::::::,,,, ,,,,,,:,,,::::i:irr:i:::, i ,,:;u0MBMOG1L:::i:::::: ,,,::, ,,, ::::::i:i:iirii:i:i: : ,iuUuuXUkFu7i:iii:i:::, :,:,: ::::::::i:i:::::iirr7iiri:: : :rk@Yizero.i:::::, ,:ii:::::::i:::::i::,::::iirrriiiri::, : 5BMBBBBBBSr:,::rv2kuii:::iii::,:i:,, , ,,:,:i@petermu., , :r50EZ8MBBBBGOBBBZP7::::i::,:::::,: :,:,::i;rrririiii:: :jujYY7LS0ujJL7r::,::i::,::::::::::::::iirirrrrrrr:ii: ,: :@kevensun.:,:,,,::::i:i:::::,,::::::iir;ii;7v77;ii;i, ,,, ,,:,::::::i:iiiii:i::::,, ::::iiiir@xingjief.r;7:i, , , ,,,:,,::::::::iiiiiiiiii:,:,:::::::::iiir;ri7vL77rrirri:: :,, , ::::::::i:::i:::i:i::,,,,,:,::i:i:::iir;@Secbone.ii:::**********************************************************************/ 12345678910111213141516/** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 123456789101112131415161718192021222324/* ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** */]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作]]></title>
    <url>%2F2017%2F08%2F25%2Fvim%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[vim的基本操作本人在实验楼学习的时候摘抄下来的，留作自己的笔记。 游标移动按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右（小写L） j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 进入插入模式在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入 命令 说明 i 在当前光标处进行编辑 I 在行首插入 A 在行末插入 a 在光标后插入编辑 o 在当前行后插入一个新行 O 在当前行前插入一个新行 cw 替换从光标所在位置后到一个单词结尾的字符 命令行模式下保存文档从普通模式输入:进入命令行模式，输入w回车，保存文档。输入:w 文件名可以将文档另存为其他文件名或存到其它路径下 命令行模式下退出vim从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑 以下为其它几种退出方式： 命令 说明 :q! 强制退出，不保存 :q 退出 :wq! 强制保存并退出 :w &lt;文件路径&gt; 另存为 :saveas 文件路径 另存为 :x 保存并退出 :wq 保存并退出 普通模式下退出vim普通模式下输入Shift+zz即可保存退出vim 普通模式下删除vim文本信息进入普通模式，使用下列命令可以进行文本快速删除： 命令 说明 x 删除游标所在的字符 X 删除游标所在前一个字符 Delete 同x dd 删除整行 dw 删除一个单词（不适用中文） d$或D 删除至行尾 d^ 删除至行首 dG 删除到文档结尾处 d1G 删至文档首部 除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：2dd表示一次删除2行i 重复执行上次命令在普通模式下.(小数点)表示重复上一次的命令操作 执行指定次数相同的命令进入普通模式输入N，N表示重复后面的次数 例如：输入10x，删除10个连续字符 输入3dd，将会删除3行文本 在普通模式下，你还可以使用dw或者daw(delete a word)删除一个单词，所以你可以很容易的联想到dnw(n替换为相应数字)表示删除n个单词 游标的快速跳转普通模式下，下列命令可以让光标快速调转到指定位置，我们分别讨论快速实现行间跳转和行内跳转 行间跳转 命令 说明 nG(n Shift+g) 游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号) gg 游标移动到到第一行 G(Shift+g) 到最后一行 小技巧：你在完成依次跳转后，可以使用Ctrl+o快速回到上一次(跳转前)光标所在位置,这个技巧很实用，比如当你在写代码时，忽然想起有个bug，需要修改，这时候你跳过去改好了，只需要按下Ctrl+o就可以回到你之前的位置。vim中会用很多类似的小技巧就等着你去发掘。 行内跳转普通模式下使用下列命令在行内按照单词为单位进行跳转 命令 说明 w 到下一个单词的开头 e 到下一个单词的结尾 b 到前一个单词的开头 ge 到前一个单词的结尾 0或^ 到行头 $ 到行尾 f&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用) F&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配的位置 t&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用) T&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用) 复制粘贴和剪切复制及粘贴文本 ● 普通模式中使用y复制 ○ 普通模式中，yy复制游标所在的整行（3yy表示复制3行） ○ 普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。 ○ 普通模式中，y$ 复制至行尾。含光标所在处字符。 ○ 普通模式中，yw 复制一个单词。 ○ 普通模式中，y2w 复制两个单词。 ○ 普通模式中，yG 复制至文本末。 ○ 普通模式中，y1G 复制至文本开头。 ● 普通模式中使用p粘贴 ○ 普通模式中，p(小写)代表粘贴至光标后（下） ○ 普通模式中，P(大写)代表粘贴至光标前（上） 剪切及粘贴其实前面讲得dd删除命令就是剪切，你每次dd删除文档内容后，便可以使用p来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行 字符的替换及撤销(Undo操作)替换和撤销(Undo)命令替换和Undo命令都是针对普通模式下的操作 命令 说明 r+&lt;待替换字母&gt; 将游标所在字母替换为指定字母 R 连续替换，直到按下Esc cc 替换整行，即删除游标所在行，并进入插入模式 cw 替换一个单词，即删除一个单词，并进入插入模式 C(大写) 替换游标以后至行末~反转游标所在字母大小写 u{n} 撤销一次或n次操作 U(大写) 撤销当前行的所有修改 Ctrl+r redo，即撤销undo的操作 快速缩进使用命令进行快速调整缩进操作 ● 普通模式下输入15G，跳转到15行 ● 普通模式下输入&gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽） ● 普通模式下输入&lt;&lt; 整行向左回退 ● 普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数 shiftwidth命令shiftwidth命令是指上一节&gt;&gt;命令产生的缩进（可以简写成sw） 普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数 获取目前的设定值 :set shiftwidth? 设置缩进为10个字符 :set shiftwidth=10 输入ESC回到普通模式，再次尝试&gt;&gt;看缩进量是否变化 调整文本位置命令行模式下输入:ce(center)命令使本行内容居中 :ce 命令行模式下输入:ri(right)命令使本行文本靠右 :ri 命令行模式下输入:le(left)命令使本行内容靠左 :le 查找快速查找普通模式下输入/然后键入需要查找的字符串 按回车后就会进行查找。 ？与/功能相同，只不过？是向上而/是向下查找。 进入查找之后，输入n和N可以继续查找 n表示继续查找，N反向查找 高级查找● 普通模式下输入\*寻找游标所在处的单词 ● 普通模式下输入\#同上，但 \# 是向前（上）找，\*则是向后（下）找 ● 普通模式下输入g\*同\* ，但部分符合该单词即可 ● 普通模式下输入g\#同\# ，但部分符合该单词即可 以上查找n,N 的继续查找命令依然可以用 多文件编辑使用vim编辑多个文件编辑多个文件有两种形式，一种是在进入vim前使用的参数就是多个文件。另一种就是进入vim后再编辑其他的文件。同时创建两个新文件并编辑 $ vim 1.txt 2.txt 默认进入1.txt文件的编辑界面12● 命令行模式下输入:n编辑2.txt文件，可以加!即:n!强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件● 命令行模式下输入:N编辑1.txt文件，可以加!即:N!强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件 进入vim后打开新文件12345678● 命令行模式下输入:e 3.txt 打开新文件3.txt● 命令行模式下输入:e# 回到前一个文件● 命令行模式下输入:ls可以列出以前编辑过的文档● 命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑● 命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目● 命令行模式下输入:e! 4.txt，新打开文件4.txt，放弃正在编辑的文件● 命令行模式下输入:f 显示正在编辑的文件名● 命令行模式下输入:f new.txt，改变正在编辑的文件名字为new.txt 恢复文件如果因为断电等原因造成文档没有保存，可以采用恢复方式，vim -r进入文档后，输入:ewcover 1.txt来恢复 $ vim -r 1.txt 可视模式可视模式命令简介12345● 在普通模式下输入v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。 ● 在普通模式下输入Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次Shift+v就可以取消选取。● 在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次Ctrl+v取消选取。● 在可视模式下输入d删除选取区域内容● 在可视模式下输入y复制选取区域内容 视窗操作视窗操作简介vim可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为vim的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入:new 打开一个新的vim视窗，并进入视窗编辑一个新文件（普通模式下输入Ctrl+w也可以,但是Ctrl+w在chrome下会与chrome关闭标签页的快捷键冲突，所以使用该快捷键你可以在IE或其它浏览器进行练习），除了:new命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：12345678910111213141516● 命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt● 命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt● 普通模式下Ctrl-w s 将当前窗口分割成两个水平的窗口● 普通模式下Ctrl-w v 将当前窗口分割成两个垂直的窗口● 普通模式下Ctrl-w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!● 普通模式下Ctrl-w o 打开一个视窗并且隐藏之前的所有视窗● 普通模式下Ctrl-w j 移至下面视窗● 普通模式下Ctrl-w k 移至上面视窗● 普通模式下Ctrl-w h 移至左边视窗● 普通模式下Ctrl-w l 移至右边视窗● 普通模式下Ctrl-w J 将当前视窗移至下面● 普通模式下Ctrl-w K 将当前视窗移至上面● 普通模式下Ctrl-w H 将当前视窗移至左边● 普通模式下Ctrl-w L 将当前视窗移至右边● 普通模式下Ctrl-w - 减小视窗的高度● 普通模式下Ctrl-w + 增加视窗的高度 文档加密创建加密文档$ vim -x file1 输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码 在vim执行外部命令在命令行模式中输入!可以执行外部的shell命令123● :!ls 用于显示当前目录的内容● :!rm FILENAME用于删除名为 FILENAME 的文件● :w FILENAME可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件 帮助系统vim中的查看帮助123● 普通模式下按F1打开vim自己预设的帮助文档● 命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件● 命令行模式下输入:ver 显示版本及参数 功能设定vim的功能设定可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用 获取目前的设定1234● 命令行模式下输入:set或者:se显示所有修改过的配置● 命令行模式下输入:set all 显示所有的设定值● 命令行模式下输入:set option? 显示option的设定值● 命令行模式下输入:set nooption 取消当期设定值 set功能的说明12345● 命令行模式下输入:set autoindent(ai) 设置自动缩进● 命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开● 命令行模式下输入:set background=dark或light，设置背景风格● 命令行模式下输入:set backup(bk) 设置自动备份，默认未打开● 命令行模式下输入: set cindent(cin) 设置C语言风格缩进]]></content>
      <tags>
        <tag>ubuntu基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器安装问题补充（安装时Select and install software失败）]]></title>
    <url>%2F2017%2F08%2F25%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[服务器安装问题补充之前写好的服务器安装教程已经写好了，针对与大部分服务器的安装应该都可以正常安装了，但是近期安装实验室服务器的时候遇到了问题。安装时Select and install software失败，这个问题在以前没有遇到过，不过也有可能时启动盘做的有问题吧，不过是刚从ubuntu官网上下载的系统做的启动盘，有点迷，不过先记录一下好了。 解决方案先跳过该步骤根据系统的提示遇到这个步骤的时候我们可以选择重新再来一次，也可以直接跳过该步骤，这个地方我尝试过，就算你重新再来几次也是这样的。当然如果你选择重新安装系统，如果没有换系统盘的话还是这样的，换了以后我也不确定的。 所以再此我选择跳过此步骤，直接开始下面的安装，最后安装完成，重启完成 跳过后的问题及解决方案问题描述跳过上面的步骤以后我们发现我们可以正常的进入系统。但是呢，在这个时候我们开始安装一些必要的软件的时候，我们会发现根本找不到安装包的，并且在输入的时候也不能补全命令。 问题解决无法找到安装包这个时候我们可以发现其实是因为我们apt的源有问题，当然开始的时候它也会让你找CD的路径来进行安装，虽然应该可以通过外接CD或者硬盘然后通过路径来安装，不过这样很是麻烦，所以我们必须要修复它。 这个时候我们可以去更新apt的源，这里建议使用清华的源，比较方便比较快。清华源的网站：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 具体操作（因为没有安装vim呢，所以这里我们只能使用vi或者nano来进行文件系统的改写） 1sudo vi /etc/apt/sources.list 然后可以把里面的东西都删除掉或者使用“#”都注释掉下面开始往里面方源了，vi的操作跟vim的操作是一样的 下面是我填写的源，可以照着填：12345678910deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse 无法自动补全命令为了提高我们的效率我们一般会用Tab键进行补全的，这个时候我在进行安装的时候install并不能自动补全，所以我进行如下操作： 1sudo apt install bash-completion 然后重启就可以了，问题解决。 服务器的远程配置正常安装ubuntu系统的时候在出错的这一步我们其实是可以选择打开ssh远程登陆的，但是此时系统安装这一步出错了，我们应该怎么打开ssh远程登陆的，毕竟对于服务器我们不能每个人都坐在服务器前面插个显示器来用。 首先安装sshsudo apt-get install openssh-server 理论上来说安装了ssh以后服务器的ssh会自动打开的，如果不放心可以查看一下 ps -e |grep ssh 如果看到sshd那说明ssh-server已经启动了。如果没有则可以这样启动： 1sudo /etc/init.d/ssh start 或者1service ssh start ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号然后重启SSH服务：12sudo /etc/init.d/ssh stopsudo /etc/init.d/ssh start 禁用root登陆其实这个也可以不禁用的，但是为了安全，我们一般都是禁用root直接远程登陆的。禁用的方法：修改/etc/ssh/ssh_config文件将其中的PermitRootLogin改成no就可以了，不过如果配置文件中没有这个的话，也可以直接手动输入。然后重启ssh服务就可以了 /etc/rc.d/sshd restart 当然如果为了安全的话，其实我们可以直接禁用掉密码登陆，采取用密钥登陆的方式，这样更安全。因为其实你的密码很容易被别人截获的，这个可以参看之前的博客进行设置。另外补充一句：其实咱们使用的账户及密码等信息保存在 /etc/passwd 以及 /etc/shadow 中，密码采用crypt（）算法加密保存了而已。]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言编写程序计时]]></title>
    <url>%2F2017%2F08%2F22%2FC%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[C语言编写程序计时在我们编程的时候，有时候需要我们去监测程序运行的时间问题，尤其是在做加速或者做优化的时候，一个程序运行的时间也许就是我们判断程序好坏的标准，所以我们有时候要进行计时。（因为用到了，所以做个记录方便下次查看） 在windows上进行计时123456789101112131415161718#include "stdio.h"#include "time.h"clock_t start_time, finish_time;/*计时*/double cord_time;/*计时*/int main(int argc, char* argv[])&#123; start_time = clock();/*****************************计时开始***********************************/ /*******************/ /*这里编写程序*/ /*******************/ finish_time = clock();/***************************计时结束***********************************/ //显示总的用时 cord_time = (double)(finish_time - start_time) ; printf("time=%f ms\n", cord_time); return 0;&#125; 在linux上进行计时123456789101112131415161718192021222324252627282930313233#include "stdio.h"#include &lt;sys/time.h&gt;int time_substract(struct timeval *result, struct timeval *begin,struct timeval *end)&#123; if(begin-&gt;tv_sec &gt; end-&gt;tv_sec) return -1; if((begin-&gt;tv_sec == end-&gt;tv_sec) &amp;&amp; (begin-&gt;tv_usec &gt; end-&gt;tv_usec)) return -2; result-&gt;tv_sec = (end-&gt;tv_sec - begin-&gt;tv_sec); result-&gt;tv_usec = (end-&gt;tv_usec - begin-&gt;tv_usec); if(result-&gt;tv_usec &lt; 0) &#123; result-&gt;tv_sec--; result-&gt;tv_usec += 1000000; &#125; return 0;&#125;int main(int argc, char* argv[])&#123; struct timeval start,stop,diff; memset(&amp;start,0,sizeof(struct timeval)); memset(&amp;stop,0,sizeof(struct timeval)); memset(&amp;diff,0,sizeof(struct timeval)); gettimeofday(&amp;start,0); /*******************/ /*这里编写程序*/ /*******************/ gettimeofday(&amp;stop,0); time_substract(&amp;diff,&amp;start,&amp;stop); printf("Total time : %d s,%d us\n",(int)diff.tv_sec,(int)diff.tv_usec); return 0;&#125;]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言TXT文件的读写]]></title>
    <url>%2F2017%2F08%2F22%2FC-%E8%AF%AD%E8%A8%80TXT%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[C语言编写TXT文件的读写本文针对的是对txt文件中数据的读写操作（非二进制的，二进制的可能后面会补充）,因为用到做个记录。 C语言编写TXT文件的读12345678910111213141516171819void Read_file(double **Matrix, char *FileName, int height, int wide)&#123; FILE *fp = fopen(FileName, "r"); if (!fp) &#123; printf("can't open file\n"); &#125; else &#123; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; wide; j++) &#123; fscanf(fp, "%lf", &amp;Matrix[i][j]); &#125; &#125; &#125; fclose(fp);&#125; C语言编写TXT文件的写1234567891011121314151617FILE *fp = fopen(output, "w+");if (!fp)&#123; printf("can't open file\n");&#125;else&#123; for (int i = 0; i &lt; FC_height; i++) &#123; for (int j = 0; j &lt; FC_wide; j++) &#123; fprintf(fp, "%lf\t", FC_matrix[i][j]); &#125; fprintf(fp, "\n"); &#125;&#125; fclose(fp);]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件脚本编写问题]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E9%97%AE%E9%A2%98-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[文件脚本编写问题在编写脚本的时候我们可能会遇到一些各种各样的小问题，比如放置位置，以及使用权限等。 文件脚本编写好以后可以直接放置到 /usr/local/sbin 目录下面，这样就可以不用去申请环境变量了，使用起来也就比较方便了。 chmod a+x [文件名] 付给权限]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理集群的脚本]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%B8%85%E7%90%86%E9%9B%86%E7%BE%A4%E7%9A%84%E8%84%9A%E6%9C%AC-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[清理集群的脚本该脚本旨在重新配置hadoop的时候我们需要清理一下集群中的东西，比如记录等。 clear.sh源代码例子123456#!/bin/bashstop-all.shxrm.sh /tmp/hadoopxrm.sh /hadoop/logsecho "clean done!"(主要为了清除tmp下面的文件hadoop还有logs)]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化集群]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%86%E7%BE%A4-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[初始化集群该脚本主要时对第一次使用集群的时候进行一个初始化。 init.sh源代码例子123#!/bin/bash hdfs namenode -formatstart-all.sh 或者12start-dfs.shstart-yarn.sh 创建目录1./bin/hdfs dfs -mkdir -p /user/hadoop 查看显示目录1hadoop fs –ls -R /]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点 文件删除脚本编写]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9-%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[所有节点 文件删除脚本编写该脚本旨在删除所有节点上相同的东西，比如hadoop的重新配置等，还有删除hadoop的log等文件，都比较方便。 xrm.sh的源代码例子12345678910111213141516171819202122232425#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fi#get first argumentarg1=$1;cuser=`whoami`fname=`basename $arg1`dir=`dirname $arg1`if [ $dir == "." ] ; thendir=`pwd`# echo $dirfiecho -----------------rming $arg1 from localhost-------------;rm -rf $arg1echofor (( i=200;i&lt;=500;i=i+100)) ;doecho ---------------rming $arg1 from s$i -------------;ssh s$i rm -rf $dir/$fnameechodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点 文件拷贝脚本编写]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9-%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[所有节点 文件拷贝脚本编写该脚本旨在往每个节点拷贝数据，之前我们的拷贝是需要自己一个节点一个节点链接然后拷贝，但是如果我们每个节点都拷贝同样的数据时，这样做显然很麻烦，如果节点多的话还很浪费时间，这样我们就可以通过该脚本自己循环拷贝。 xcp.sh源代码例子12345678910111213141516171819202122232425#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fi#get first argumentarg1=$1;cuser=`whoami`fname=`basename $arg1`dir=`dirname $arg1`if [ $dir == "." ] ; thendir=`pwd`# echo $dirfifor (( i=200;i&lt;=500;i=i+100)) ;doecho -----------coping $arg1 to $i------------------;if [ -d $arg1 ] ; thenscp -r $arg1 $cuser@s$i:$direlsescp $arg1 $cuser@s$i:$dirfiechodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点执行同一指令的操作]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%90%8C%E4%B8%80%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[所有节点执行同一指令的操作该脚本旨在对每个节点都执行同一个指令，这样就不用每次都shell到每个子节点上去执行了，较为方便。 xcall.sh的源代码例子123456789101112131415#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fiecho -----------------xcall $arg1 from localhost-----------------$@echo#get first argumentfor (( i=0;i&lt;=3;i=i+1));do echo --------------------xcall $arg1 from Slave$i ------------------;ssh Slave$i $@echodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点 文件查看脚本编写]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[所有节点 文件查看脚本编写该脚本用于一次查看所有集群节点相同位置下的文件，类似于手动在每个节点上输入ls指令进行查看。 xls.sh的源代码例子12345678910111213141516171819202122#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fi#get first argumentarg1=$1;cuser=`whoami`fname=`basename $arg1`dir=`dirname $arg1`if [ $dir == "." ] ; thendir=`pwd`# echo $dirfifor (( i=200;i&lt;=500;i=i+100)) ;doecho ---------------ls $arg1 from s$i -------------;ssh s$i ls $dir/$fname | xargsechodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展Slave的时候需要注意的一些问题]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%A9%E5%B1%95Slave%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[扩展Slave的时候需要注意的一些问题 扩展的时候可以先直接按照Hadoop集群安装配置教程先进行。 这里需要更改 /usr/local/hadoop/etc/hadoop 路径下的 slave文件中的参数，需要把添加的节点加进去。 并且在Master里面的 /etc/hosts 中添加新加节点的IP和节点的命名。（如果想用节点的命名来连接任意一台节点计算机的话，我们需要把这个操作在每台节点计算机上进行） 如果存在改变节点名字的操作，在文件scp传输的时候可能会有错误，但是在警告中下面的语句有提示让移除之前命名和IP的对应关系，复制下来直接操作就可以了，然后在接着使用scp进行文件传输就没有什么问题了。]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop安装_单机伪分布式配置]]></title>
    <url>%2F2017%2F08%2F16%2FHadoop%E5%AE%89%E8%A3%85_%E5%8D%95%E6%9C%BA%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hadoop安装_单机伪分布式配置创建hadoop账户添加用户： sudo useradd -m hadoop -s /bin/bash 给用户设置密码： sudo passwd hadoop 给用户管理员权限： sudo adduser hadoop sudo 更新apt sudo apt-get update 安装vim: sudo apt-get install vim 安装SSH、配置SSH无密码登陆sudo apt-get install openssh-server ssh localhost exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 此时再 ssh localhost 时就可以无密码访问了。 安装Java环境sudo apt-get install openjdk-8-jre openjdk-8-jdk dpkg -L openjdk-8-jdk | grep &#39;/bin/javac&#39; vim ~/.bashrc export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 source ~/.bashrc # 使变量设置生效 检查是否正确： echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，一般选择下载最新的稳定版本，即下载 “stable” 下的 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 我们选择将 Hadoop 安装至 /usr/local/ 中： sudo tar -zxf ~/下载/hadoop-2.7.3.tar.gz -C /usr/local # 解压到/usr/local中 cd /usr/local/ sudo mv ./hadoop-2.7.3/ ./hadoop # 将文件夹名改为hadoop sudo chown -R hadoop ./hadoop # 修改文件权限 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： cd /usr/local/hadoop ./bin/hadoop version Hadoop单机配置(非分布式)【这一步个人认为可以用来检测hadoop是否安装成功，可以不用管的】 cd /usr/local/hadoop mkdir ./input cp ./etc/hadoop/*.xml ./input # 将配置文件作为输入文件 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output &#39;dfs[a-z.]+&#39; （和上面一行连着的） cat ./output/* # 查看运行结果 rm -r ./output Hadoop伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。 Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (通过 vim 编辑会比较方便: vim ./etc/hadoop/core-site.xml)，将当中的1234567891011121314&lt;configuration&gt;&lt;/configuration&gt;修改为下面配置：&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同样的，修改配置文件 hdfs-site.xml：1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置完成后，执行 NameNode 的格式化:成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。 接着开启 NameNode 和 DataNode 守护进程。 ./sbin/start-dfs.sh 输入yes（可能第一次需要）启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。成功启动后，可以访问 Web 界面 http://localhost:50070/ 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。 运行Hadoop伪分布式实例（配置时其实也可以不用管，它只是跑了一个例子） 上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录： ./bin/hdfs dfs -mkdir -p /user/hadoop 接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input: ./bin/hdfs dfs -mkdir input ./bin/hdfs dfs -put ./etc/hadoop/*.xml input 复制完成后，可以通过如下命令查看文件列表： ./bin/hdfs dfs -ls input 伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output &#39;dfs[a-z.]+&#39; 查看运行结果的命令（查看的是位于 HDFS 中的输出结果）： ./bin/hdfs dfs -cat output/* 我们也可以将运行结果取回到本地： rm -r ./output # 先删除本地的 output 文件夹（如果存在） ./bin/hdfs dfs -get output ./output # 将 HDFS 上的 output 文件夹拷贝到本机 cat ./output/* Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹: ./bin/hdfs dfs -rm -r output # 删除 output 文件夹 若要关闭 Hadoop，则运行 ./sbin/stop-dfs.sh 启动YARN（伪分布式不启动 YARN 也可以，一般不会影响程序执行） YARN 是从 MapReduce 中分离出来的，负责资源管理与任务调度。YARN 运行于 MapReduce 之上，提供了高可用性、高扩展性 上述通过 ./sbin/start-dfs.sh 启动 Hadoop，仅仅是启动了 MapReduce 环境，我们可以启动 YARN ，让 YARN 来负责资源管理与任务调度。 首先修改配置文件 mapred-site.xml，这边需要先进行重命名： mv ./etc/hadoop/mapred-site.xml.template ./etc/hadoop/mapred-site.xml 然后再进行编辑，同样使用 vim 编辑 vim ./etc/hadoop/mapred-site.xml ：123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 接着修改配置文件 yarn-site.xml：123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 然后就可以启动 YARN 了（需要先执行过 ./sbin/start-dfs.sh）： ./sbin/start-yarn.sh # 启动YARN ./sbin/mr-jobhistory-daemon.sh start historyserver # 开启历史服务器，才能在Web中查看任务运行情况 开启后通过 jps 查看，可以看到多了 NodeManager 和 ResourceManager 两个后台进程启动 YARN 之后，运行实例的方法还是一样的，仅仅是资源管理方式、任务调度不同。观察日志信息可以发现，不启用 YARN 时，是 “mapred.LocalJobRunner” 在跑任务，启用 YARN 之后，是 “mapred.YARNRunner” 在跑任务。启动 YARN 有个好处是可以通过 Web 界面查看任务的运行情况：http://master:8088/cluster， 同样的，关闭 YARN 的脚本如下： ./sbin/stop-yarn.sh ./sbin/mr-jobhistory-daemon.sh stop historyserver 参考资料Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS：http://www.powerxing.com/install-hadoop-cluster/ Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04http://www.powerxing.com/install-hadoop/]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群安装配置教程]]></title>
    <url>%2F2017%2F08%2F16%2FHadoop%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hadoop集群安装准备工作Hadoop 集群的安装配置大致为如下流程: 1、选定一台机器作为 Master 2、在 Master 节点上配置 hadoop 用户、安装 SSH server、安装 Java 环境 3、在 Master 节点上安装 Hadoop，并完成配置 4、在其他 Slave 节点上配置 hadoop 用户、安装 SSH server、安装 Java 环境 5、将 Master 节点上的 /usr/local/hadoop 目录复制到其他 Slave 节点上 6、在 Master 节点上开启 Hadoop 创建hadoop账户添加用户： sudo useradd -m hadoop -s /bin/bash 给用户设置密码： sudo passwd hadoop 给用户管理员权限： sudo adduser hadoop sudo 更新aptsudo apt-get update 安装vim: sudo apt-get install vim 安装Java环境sudo apt-get install openjdk-8-jre openjdk-8-jdk dpkg -L openjdk-8-jdk | grep &#39;/bin/javac&#39; vim ~/.bashrc export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 source ~/.bashrc # 使变量设置生效 检查是否正确： echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，一般选择下载最新的稳定版本，即下载 “stable” 下的 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 我们选择将 Hadoop 安装至 /usr/local/ 中：sudo tar -zxf ~/下载/hadoop-2.7.3.tar.gz -C /usr/local # 解压到/usr/local中 cd /usr/local/ sudo mv ./hadoop-2.7.3/ ./hadoop # 将文件夹名改为hadoop sudo chown -R hadoop ./hadoop # 修改文件权限 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： cd /usr/local/hadoop ./bin/hadoop version 网络配置假设集群所用的节点都位于同一个局域网。 首先在 Master 节点上完成准备工作，并关闭 Hadoop (/usr/local/hadoop/sbin/stop-dfs.sh)，再进行后续集群配置。 为了便于区分，可以修改各个节点的主机名（在终端标题、命令行中可以看到主机名，以便区分）。在 Ubuntu中，我们在 Master 节点上执行如下命令修改主机名（即改为 Master，注意是区分大小写的）： 设置主机名： sudo vim /etc/hostname 设置IP sudo vim /etc/hosts 设置如下： 192.168.1.121 Master 192.168.1.122 Slave1 我们在 /etc/hosts 中将该映射关系填写上去即可，如下图所示（一般该文件中只有一个 127.0.0.1，其对应名为 localhost，如果有多余的应删除，特别是不能有 “127.0.0.1 Master” 这样的记录） 配置好后需要在各个节点上执行如下命令，测试是否相互 ping 得通，如果 ping 不通，后面就无法顺利配置成功：ping Master -c 3 # 只ping 3次，否则要按 Ctrl+c 中断ping Slave1 -c 3 继续下一步配置前，请先完成所有节点的网络配置，修改过主机名的话需重启才能生效。 SSH无密码登陆节点sudo apt-get install openssh-server Master上面操作： 首先生成 Master 节点的公匙，在 Master 节点的终端中执行（因为改过主机名，所以还需要删掉原有的再重新生成一次）： cd ~/.ssh # 如果没有该目录，先执行一次ssh localhost rm ./id_rsa* # 删除之前生成的公匙（如果有） ssh-keygen -t rsa # 一直按回车就可以 让 Master 节点需能无密码 SSH 本机，在 Master 节点上执行： cat ./id_rsa.pub &gt;&gt; ./authorized_keys 完成后可执行 ssh Master 验证一下（可能需要输入 yes，成功后执行 exit 返回原来的终端）。接着在 Master 节点将上公匙传输到 Slave1 节点：（当然多个节点的话，每个节点都要传输） scp ~/.ssh/id_rsa.pub hadoop@Slave1:/home/hadoop/ Slave1上面操作： 接着在 Slave1 节点上，将 ssh 公匙加入授权： mkdir ~/.ssh # 如果不存在该文件夹需先创建，若已存在则忽略 cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys rm ~/id_rsa.pub # 用完就可以删掉了 如果有其他 Slave 节点，也要执行将 Master 公匙传输到 Slave 节点、在 Slave 节点上加入授权这两步。（如果配置好了以后可以用 ssh Slave1 指令检验，发现可以不用密码就可以连接上了） 配置PATH变量在单机伪分布式配置教程的最后，说到可以将 Hadoop 安装目录加入 PATH 变量中，这样就可以在任意目录中直接使用 hadoo、hdfs 等命令了，如果还没有配置的，需要在 Master 节点上进行配置。首先执行 vim ~/.bashrc，加入一行： export PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin 保存后执行 source ~/.bashrc 使配置生效 配置集群/分布式环境集群/分布式模式需要修改 /usr/local/hadoop/etc/hadoop 中的5个配置文件，更多设置项可点击查看官方说明，这里仅设置了正常启动所必须的设置项： slaves、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml 。 1, 文件 slaves，将作为 DataNode 的主机名写入该文件，每行一个，默认为 localhost，所以在伪分布式配置时，节点即作为 NameNode 也作为 DataNode。分布式配置可以保留 localhost，也可以删掉，让 Master 节点仅作为 NameNode 使用。 本教程让 Master 节点仅作为 NameNode 使用，因此将文件中原来的 localhost 删除，只添加一行内容：Slave1。（相应的如果有多个节点要都添加上的） 2, 文件 core-site.xml 改为下面的配置：1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://Master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 3, 文件 hdfs-site.xml，dfs.replication 一般设为 3，但我们只有一个 Slave 节点，所以 dfs.replication 的值还是设为 1：（如果是多个节点还是改为3）【这里的参数我的理解是数据备份多少次】123456789101112131415161718&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;Slave0:50090&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 4, 文件 mapred-site.xml （可能需要先重命名，默认文件名为 mapred-site.xml.template），然后配置修改如下：1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;Master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;Master:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 5, 文件 yarn-site.xml：12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;Master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置好后，将 Master 上的 /usr/local/Hadoop 文件夹复制到各个节点上。因为之前有跑过伪分布式模式，建议在切换到集群模式前先删除之前的临时文件。 在 Master 节点上执行： cd /usr/local sudo rm -r ./hadoop/tmp # 删除 Hadoop 临时文件 sudo rm -r ./hadoop/logs/* # 删除日志文件 tar -zcf ~/hadoop.master.tar.gz ./hadoop # 先压缩再复制 cd ~ scp ./hadoop.master.tar.gz Slave1:/home/hadoop 在 Slave1 节点上执行：（如果有多个节点每个节点上都要执行一遍） sudo rm -r /usr/local/hadoop # 删掉旧的（如果存在） sudo tar -zxf ~/hadoop.master.tar.gz -C /usr/local sudo chown -R hadoop /usr/local/hadoop （如果启动不成功的话可以删除 /usr/loval 目录下的 logs和 tmp 再重新操作一次）同样，如果有其他 Slave 节点，也要执行将 hadoop.master.tar.gz 传输到 Slave 节点、在 Slave 节点解压文件的操作。 首次启动需要先在 Master 节点执行 NameNode 的格式化： hdfs namenode -format # 首次运行需要执行初始化，之后不需要 接着可以启动 hadoop 了，启动需要在 Master 节点上进行： start-dfs.sh start-yarn.sh mr-jobhistory-daemon.sh start historyserver 也可以在更目录下面执行 start-all.sh mr-jobhistory-daemon.sh start historyserver 通过命令 jps 可以查看各个节点所启动的进程。正确的话，在 Master 节点上可以看到 NameNode、ResourceManager、SecondrryNameNode、JobHistoryServer 进程 在 Slave 节点可以看到 DataNode 和 NodeManager 进程. 缺少任一进程都表示出错。另外还需要在 Master 节点上通过命令 hdfs dfsadmin -report 查看 DataNode 是否正常启动，如果 Live datanodes 不为 0 ，则说明集群启动成功。 也可以通过 Web 页面看到查看 DataNode 和 NameNode 的状态：http://master:50070/。如果不成功，可以通过启动日志排查原因。 同样可以通过 Web 界面查看任务进度 http://master:8088/cluster，在 Web 界面点击 “Tracking UI” 这一列的 History 连接，可以看到任务的运行信息 参考资料Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS：http://www.powerxing.com/install-hadoop-cluster/ Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04http://www.powerxing.com/install-hadoop/]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的github博客]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[可以根据博客中的hello-world文件中讲述的安装下面是一些详细的步骤1、安装node,可以去node的官网直接下载 https://nodejs.org/en/ （这里我下载的是node-v6.11.1-x64）2、安装hexo，可以打开cmd终端输入 npm install -g hexo-cli 3、安装完hexo后开始在电脑上建立一下自己写博客的文件夹，依旧是在cmd终端中运行 cd C:\Users\Darren\Documents #实际上是进入了电脑的文档文件夹 mkdir blog cd blog hexo init blog cd blog hexo s 然后就可以用 http://localhost:4000/ 来查看博客是否安装成功 npm install hexo-deployer-git --save 4、修改_config.yml这个配置文件 # Site title: Darren subtitle: 海亮的笔记本 description: author: Darren language: zh-Hans timezone: # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: repo是自己在自己github中建立的地址 5、开始部署 hexo d 之后可以去看一下你的博客就好了 https://huanghailiang.github.io/ 到此博客基本搭建完成了，剩下的东西就可以按照自己的兴趣去自己配置了。 如果标签没有的话需要自己新建一个hexo new page tags 里面修改为： --- title: tags date: 2017-08-15 11:06:32 type: tags ---]]></content>
      <tags>
        <tag>搭建自己的github博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习环境搭建------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[转自：碧尧博客地址 深度学习环境搭建开始接触深度学习一年多时间了，总是有种技术发展飞快，没等你掌握现有技术更牛X的技术又出来了。身处AI浪潮中，到现在越发有种感觉：深度学习可能很多问题都能解决，但我们自己并没有那么多精力去研究那么多方面，自然语言处理，自动驾驶，人脸识别等等，选定一个方向深入研究才是正解。至少目前是这么理解的，不对希望朋友指正！ 如今深度学习的框架很多，Caffe，TensorFlow，Torch等都各有各的优势，开始深度学习不可避免要配置深度学习的工作环境，如果不知道方法也许在开头就会花费很多时间，写这篇博客的目的就是帮助大家更快上手。下面介绍Caffe在Ubuntu 16.04上的搭建过程（Ubuntu 14.04同样可以） CaffeCaffe的环境搭建在几个框架中是最麻烦的，因为Caffe用到的依赖库很多，如果配置GPU版有时候显卡驱动和CUDA也能把你折腾好久。CPU版和GPU版主要差别就是在NVIDIA显卡驱动和CUDA的安装上，其他框架要用到NVIDIA显卡其实差别也就是这样，因此这也算服务器基础。两个版本有区别的地方会注明。 Nvidia driver123456789lspci | grep -i nvidiasudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-get install nvidia-352 % 版本自己查询sudo shutdown -r now 重启后用下面命令查看驱动版本 1cat /proc/driver/nvidia/version CUDA到CUDA官网下载CUDA安装文件，选择对应版本 这里有下载deb [local]文件，后面会说runfile [local]的用法，先卖个关子。下载好后cd到存放安装的文件夹，使用一下命令，文件名千万别手输，善用tab键 12345sudo dpkg -i cuda-repo-ubuntu1604*amd64.debsudo apt-get updatesudo apt-get install cuda 安装结束，添加环境变量（如果安装服务器，环境变量在每个用户下都需要添加一次，应该是有更聪明的方法，目前还没有找到） 12345echo &apos;export PATH=/usr/local/cuda/bin:$PATH&apos; &gt;&gt; ~/.bashrcecho &apos;export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc 查看安装CUDA版本 1nvcc -V 显示下图信息说明安装好了 再重启下电脑 1sudo shutdown -r now cuDNN这是深度学习训练过程中的加速算法包，到cuDNN 下载对应的安装包，cd到安装包所在文件夹 123456789tar xvf cudnn*.tgzcd cudasudo cp */*.h /usr/local/cuda/include/sudo cp */libcudnn* /usr/local/cuda/lib64/sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 上面说runfile (local)卖了个关子，可以显卡驱动和CUDA一起安装，属于比较方便的方法，和之前的方法有什么差别目前还不知道 1sudo sh cuda_8.0.61_375.26_linux.run 运行这句命令，接下来根据提示操作就好了结束后按照上面的方法添加环境变量 依赖库安装（CPU版从这里开始）12345678910111213141516171819sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential cmake g++ gfortran git pkg-config python-dev software-properties-common wgetsudo apt-get autoremovesudo rm -rf /var/lib/apt/lists/*sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compilersudo apt-get install --no-install-recommends libboost-all-devsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-devsudo apt-get install -y libatlas-base-devsudo apt-get install -y python-pip 下载Caffe123456789cd ~mkdir git //在home下新建一个git文件夹，用来存放那些从github上git下来的文件git clone https://github.com/BVLC/caffe.git //从github上git caffecd caffecp Makefile.config.example Makefile.config 修改Makefile.config 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//如果你不使用GPU的话，就将# CPU_ONLY := 1修改成：CPU_ONLY := 1//若使用cudnn，则将# USE_CUDNN := 1修改成：USE_CUDNN := 1//若使用的opencv版本是3的，则将# OPENCV_VERSION := 3修改为：OPENCV_VERSION := 3//若要使用python来编写layer，则需要将# WITH_PYTHON_LAYER := 1修改为WITH_PYTHON_LAYER := 1//重要的一项将# Whatever else you find you need goes here.下面的INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/includeLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib修改为：INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial//这是因为ubuntu16.04的文件包含位置发生了变化，尤其是需要用到的hdf5的位置，所以需要更改这一路径 创建Hdf5文件链接 1234567find . -type f -exec sed -i -e &apos;s^&quot;hdf5.h&quot;^&quot;hdf5/serial/hdf5.h&quot;^g&apos; -e &apos;s^&quot;hdf5_hl.h&quot;^&quot;hdf5/serial/hdf5_hl.h&quot;^g&apos; &apos;&#123;&#125;&apos; \;cd /usr/lib/x86_64-linux-gnusudo ln -s libhdf5_serial.so.10.1.0 libhdf5.sosudo ln -s libhdf5_serial_hl.so.10.0.2 libhdf5_hl.so 执行caffe下python文件夹下的指令 1234567cd pythonfor req in $(cat requirements.txt); do pip install $req; done\\目的是检查caffe所需要的python的库的版本，如果出现红字错误说明版本不满足要求，执行下面语句for req in $(cat requirements.txt); do sudo -H pip install $req --upgrade; done 编辑/usr/local/cuda/include/host_config.h，将其中的第115行 123#error -- unsupported GNU version! gcc versions later than 4.9 are not supported!% 改为//#error -- unsupported GNU version! gcc versions later than 4.9 are not supported! make 各种文件（cd到Caffe文件夹）123456789make all -j8 //j8代表计算机cpu有8个核，因此可以多线程一起make，这样make的速度会快很多。一般常用的还有j4make test -j8make runtest -j8make pycaffe //编译python接口make distribute 到这里搭建完毕]]></content>
      <tags>
        <tag>深度学习环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装远程图形界面x2go------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_5%2F</url>
    <content type="text"><![CDATA[转自：碧尧博客地址 手把手教你配置Ubuntu server服务器安装远程图形界面x2goUbuntu server 安装完成只有命令行界面，一般的工作在Windows下用 xshell 和 winscp ，一个输命令行，一个进行界面化文件管理，还是挺方便的， 但部分用户还是希望有个图形界面更加方便科研工作开展，这里推荐x2go这个轻量化桌面，安装也比较方便，下面就来介绍。首先在服务器上安装一些必要的软件 123456sudo apt-get install software-properties-commonsudo add-apt-repository ppa:x2go/stablesudo apt-get updatesudo apt-get install x2goserver x2goserver-xsessionsudo apt-get updatesudo apt-get install -y xfce4 xfce4-goodies xubuntu-desktop 很简单，几条命令结束就OK了。结束用 1hostname -I 查看ip，后面在Windows下要用到 然后在 Windows 或者 OS X 下安装一个客户端 x2go client ,安装结束打开会跳出如下窗口 在”Host” 中填写服务器ip“Login”中填写要登录的username“Session type”下拉菜单选择“XFCE”，点击OK结束。 在这里输入密码就可以远程连接服务器，同时拥有图形界面了。 配置服务器系列到这里就结束了，小白我自己也在后面多多积累相关的技巧，有了新的经验再来更新，希望大家支持！]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理服务器用户------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_4%2F</url>
    <content type="text"><![CDATA[转自：碧尧博客地址 手把手教你配置Ubuntu server服务器管理服务器用户管理服务器用户，一项一项开始说，首先要管理，当然要现有用户咯。添加用户我是用adduser 命令，相当于一个简单的交互过程，命令如下： 1sudo adduser username 然后会让你确定用户名，用户密码这些信息，结束后在/home目录下就有一个对应用户名的文件夹了。管理员添加用户后，用户自己可以通过 1passwd 来更新自己的密码。 哪天可能那个用户惹到root管理员了，管理员要删掉那个用户，怎么操作，非常简单 1userdel username 秒删好吧！所以不要惹管理员 如果想修改用户名有改怎么办，有几种方案 第一种，简单粗暴，按照上面的方法删掉用户重新建 第二种，优雅一点，两条命令搞定 12usermod -l New_Login_Name, -md Home_Directory Old_Login_Name groupmod -n NewName OldName 管理员会给服务器装一些基本的软件，有的用户想装自己需要的软件，但是没有权限怎么办嘞？每次都找管理员也是烦的，因此可以给部分用户 sudo 权限，怎么操作呢？修改/etc/sudoers文件，在 root ALL=(ALL) ALL下方添加要给权限的用户名 12root ALL=(ALL) ALLusername ALL=(ALL) ALL 还有种方法就是直接创建管理者账号 1sudo adduser username sudo 以上就是一些最基本的用户管理指令，刚开始是够用了，到后面反正慢慢积累嘛]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置服务器网络------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_3%2F</url>
    <content type="text"><![CDATA[转自：碧尧博客地址 手把手教你配置Ubuntu server服务器设置服务器网络之前两篇讲了服务器系统安装和硬盘挂载，这篇总结下网络设置。具体开始讲之前先说说如何实现其他人可以访问服务器。一种方法是由一个网口出来接路由器，用户都连接到路由器的网络上，不管是通过有线还是WiFi，把用户都归到同一个网络下。另一种方法就比较bug了，像清华大学那样，整个学校有线网和无线的Tsinghua都是同一个网络，所以就不需要路由器了，之前不知道还倒腾了很久。又有人要问了，那如何让外网的人可以访问服务器呢？不好意思，我没有研究过，另一个原因也是担心网络安全的问题，毕竟没有学过相关的知识，所以搭个服务器内部用就完了。如果有大神在这方面比较有研究，我也非常欢迎交流。（邮箱：shaobiyao@gmail.com）说回来，先解决基本问题再说 sudo vim /etc/network/interfaces 修改如下部分： auto eth0（这个名称每台机器不一样，可以通过ifconfig -a查询）iface eth0 inet staticaddress 192.168.0.117 #选用同一个网络下不冲突的ipgateway 192.168.0.1 #gateway and netmask 可以通过查看同一网络下的Windows电脑的信息获得，都一样的netmask 255.255.255.0 sudo vim /etc/resolvconf/resolv.conf.d/base(网上有说修改/etc/resolv.conf的，这个文件修改完会被系统覆盖，等于白改)nameserver XXX.XXX.XXX.XXX #和同一网络中Windows的电脑一样 重启网卡： sudo /etc/init.d/network restart 用ping www.baidu.com测试是否成功]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器多硬盘挂载------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_2%2F</url>
    <content type="text"><![CDATA[转自：碧尧博客地址 手把手教你配置Ubuntu server服务器服务器多硬盘挂载现在科研中需要处理的数据量经常性会非常大，因此服务器基本都会采用固态硬盘加机械硬盘的解决方案来实现服务器性能和成本的平衡，系统装在固态中，用户数据和数据集存放在机械硬盘中。接下来就讲下如何挂载硬盘 参考网页： http://zwkufo.blog.163.com/blog/static/258825120141283942244/http://www.jianshu.com/p/5c12289dbcd1sudo fdisk –lu (查看当前硬盘及分区情况) 可以看到类似界面 列表中我们可以看到所有硬盘，找到要挂载的硬盘名称，例如/dev/sdb sudo fdisk /dev/sdb(这里为想要挂载的硬盘名称)，利用该命令可以对硬盘进行分区，具体可以参考网页1中的讲解更加详细 sudo mkfs –t ext4 /dev/sdb(硬盘格式化，-t ext4 表示将分区格式化成ext4文件系统类型) sudo df –l(显示硬盘挂载情况)sudo mount –t ext4 /dev/sdb(想要挂载的硬盘) /devdata(目标挂载点)结束后可以用sudo df –l 查看是否成功 配置系统启动自动挂载，修改/etc/fstab文件，添加/devdata was on /dev/sdbUUID=37eaa526-5d96-4237-8468-603df5216ce9 /devdata(挂载点) ext4 defaults 0 2硬盘的UUID通过命令 sudo blkid 进行查看 这样就把/dev/sdb挂载到/devdata这个文件夹下了。有人要问了，我不要挂这里，要把硬盘挂到/home目录下怎么办？接下来就是解决这个问题 首先要做的是卸载原先的挂载点，怎么做，很简单， sudo umount /dev/sdb(这里好像是写挂载的文件夹名也可以，但我没有试过)，再用 sudo df -l 查看，原先挂载的硬盘就没有了。 接下来你得挂载已经分区好的硬盘，然后把 home 目录下的全部文件拷贝到硬盘挂载的目录下。然后删除 home 目录，最后把第一步挂载好的新硬盘重新挂载在 home 目录下。 挂载设置好的硬盘 同步 home 目录所有文件，删除之前的 home 目录下的所有文件 确定同步成功之后，删除旧 home 目录 重新挂载新硬盘并设置启动挂载 这里如果失败的话就修改/etc/fstab文件，把原先的挂载点改成/home再 sudo df -l，就可以看到成功挂载到/home下了，不过这样对新机器是没什么影响，如果原先机器上有非root用户，这样操作后就GG了，还是要做好数据备份]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu server 16.04 安装教程------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_1%2F</url>
    <content type="text"><![CDATA[转自：碧尧博客地址 手把手教你配置Ubuntu server服务器近期实验室来了台新的服务器，第一次从头到尾把配置过程走了一遍，特来此总结一番，希望可以帮助到想入坑的童鞋。我将从以下几个方面来总结配置服务器的过程(系统版本为Ubuntu server 16.04) Ubuntu server 16.04 安装教程 服务器多硬盘挂载 设置服务器网络 管理服务器用户 安装远程图形界面x2go Ubuntu server 16.04 安装教程 Ubuntu server 16.04 启动U盘制作用装系统，没启用U盘怎么行呢！Ubuntu系统的启动U盘制作非常简单，首先从官网下载对应版本的系统镜像文件，下一步你需要一个空白的U盘，用于写入镜像文件，如果U盘中有资料千万做好备份。写入镜像文件的软件可以使用软碟通。 用软碟通打开镜像文件 菜单中“启动”-&gt;“写入硬盘映像” 写入U盘中，点击“写入”，然后就可以吃着火锅唱着歌等着进度条跑完就好了 安装Ubuntu serverMarkdown Extra 表格语法：首先用U盘启动，之前需要查下主板进入boot menu的快捷键（一般是Esc，Del，F2，F12等），选择自己U盘启动（可能会有一个UEFI选项，两者都行） 2017.7.12 update: 推荐大家安装时都选择英文版本，有时候选择中文版在最后安装的时候会报一些没办法解决的错误 用启动盘成功引导之后，出现下面的界面，恭喜你完成了第一步 选择语言你喜欢什么语言就什么语言咯 选择是否继续安装所选择的语言版本，选择”yes 选择”否”，默认键盘模式就好了 然后等进度条跑完，到这里键盘就已经好了，下面来配置服务器的一些基本信息。主机名自己起，但只能用字母和数字 激动人心的时候到了，设置服务器的第一个用户，没错，就是你啦 设置密码 要不要加密主目录，先“否”吧 设置时区，还是默认 接下来就是最关键的，选择系统安装硬盘，作者小白就不用“手动”了 这里选择空白区（理想情况就是系统装在固态中，然后再挂载一个大的机械硬盘） 这里我是选了一块空白的固态，大小是“max” 分区设定结束并将修改写入磁盘，结束后出现下面窗口 用空格选择：OpenSSH server 选择“yes” “continue”重启，完工 网络什么的安装过程不配置都没有问题，系统装好了再解决，放心大胆搞，最坏就是重装嘛，硬件一般不会搞坏。今天先写到这里，后面我接着按照前面的大纲更新，其实网上这些东西都有，我就是帮大家归纳总结下，希望对大家有帮助吧]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu密钥登录教程]]></title>
    <url>%2F2017%2F07%2F22%2Fubuntu%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ubuntu密钥登录教程上文已经讲诉了ubuntu系统设置密匙登陆，接下来讲解一下如何登陆。本文使用XShell进行远程连接使用WinSCP来进行ubuntu与ubuntu之间的文件的传输 XShell首先现在登录时输入密码那一栏已经变成了灰色，这个时候只能使用密匙登录了。拿到密钥的第一步可以先添加密钥 找到自己密钥的路径即可 密钥导入进来以后那个文件就可以不要了，当然如果还有其他地方需要的话还需要导入其他的地方，不过如果误删了不要方，旁边还有导出呢。导入成功以后可以进入属性 大家可以更改密码，初始密码都为空的，这个地方相当于你再给你的密钥又手动加了一层密码，当然也可以不加，因为我发现加了以后登录的时候还要你自己输入一遍。属性上面还有一公钥，这个里面就是我们放到服务器中的东西，这个东西不要给别人，当然我给你们的密匙你们更不能给别人，否者别人就可以轻松的登录你的账号了。剩下的登录方法更以前一样。 WinSCP同样此时winscp用密码也登录不上了确认 直接在之前建立的那个里面更改就好，点击编辑然后点高级 验证 然后添加密钥文件的路径 右下角选择所有文件 选择密匙然后有一个格式转换，选择确定 然后保存确定保存就完了，大功告成可以链接了。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 系统设置密钥登陆]]></title>
    <url>%2F2017%2F07%2F22%2FUbuntu%20%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[Ubuntu 系统设置密钥登陆本文主要参考文档 http://www.downgle.com/zt/zqxouw0qwvstzrouysrloolz.html http://blog.csdn.net/kenhins/article/details/51585565自己简单整理留作备份以备后期查看个人感觉用密钥登陆比用密码登陆安全很多，所以一旦生成密码之后一定不要将自己的密钥给别人，否者别人将很轻松的登陆你的账户，当然我发现如果你使用XShell远程连接ubuntu服务器的时候你可以再给密钥加上一层密码的。 密钥的生成这一步如果你使用XShell的话其实很简单，在上面的工具中有一个“新建用户密钥生成向导”，进去你自己一定会的，这里就不多说了 设置密钥登陆首先需要修改一些配置文件 vim /etc/ssh/sshd_config 进入sshd_config文件后需要更改几个地方 PubkeyAuthentication yes #启用公告密钥配对认证方式 AuthorizedKeysFile %h/.ssh/authorized_keys #设定PublicKey文件路径 RSAAuthentication yes #允许RSA密钥 PasswordAuthentication no #禁止密码验证登录,如果启用的话,RSA认证登录就没有意义了 #禁用root账户登录，非必要，但为了安全性，请配置 PermitRootLogin no 其实我在配置的时候发现其中有些找了很多遍都没有找到，然后我就直接手动照着输入一遍也是可以的。 然后保存配置，重新启动服务 service sshd restart 配置密钥由上面的配置文件我们可以看出来密钥放置的位置应该在用户根目录下的.ssh/authorized_keys中，如果系统本身就有authorize_keys，那么你就可以直接将你的公钥复制进来但是一般情况下刚装好的新机器没有这个目录，这就需要我们先生成一个(这里我们可以直接进入你要创建的账户去进行，可以使用指令 su 需要创建的用户名) ssh-keygen 输入该指令后一路回车即可回头用指令 ll 你可以发现在当前用户的更目录下就会生成一个 .ssh的文件夹,然后再进入这个文件夹操作 cd ~/.ssh vim authorized_keys 把自己生成的公钥复制进来就可以了然后保存，并且更改文件模式 chmod 600 authorized_keys 注意：有些时候复制的时候可能不全，尤其前面缺少几个字母，这个需要自己检查一下，否则登陆会不成功的]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统时ubuntu更改开机引导]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6ubuntu%E6%9B%B4%E6%94%B9%E5%BC%80%E6%9C%BA%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[我们在windows上安装ubuntu双系统的时候，ubuntu的引导会默认先进入ubuntu系统，这对于那些想使用ubuntu但是并不常用ubuntu系统的人有一些不方便。在网上我有看到EaseBCD这个软件可以用来管理启动项的。但是因为个人之前和身边的朋友使用过，感觉其实并没有解决用户的问题，不安装EaseBCD的时候只用进入一次选择界面，而安装完EaseBCD的时候我们竟然需要进入两次引导界面，这就很不方便。（此处之争对ubuntu其他的双系统也许EaseBCD会更加方便些）另外之前一个朋友发现这个地方很不方便，于是就卸载了EaseBCD结果他的系统完全进不去了，最后在大神的指导下才修复进入了windows系统。说了这么多到底如何更改启动项呢？其实使用ubuntu自带的系统文件就可以了。 根据ubuntu自带的系统文件就可以修改启动顺序进入系统文件 sudo vim /etc/default/grub 进去之后找到GRUB_DEFAULT，它代表启动顺序。然后后面的数字需要根据自己电脑开机时显示的顺序进行选择当然里面还有很多的文件，还可以修改其他的参数，比如，选择界面等待的时间等（默认是10s,如果觉得开机时间太久了，可以自行更改的）]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu环境下降低gcc和g++的版本]]></title>
    <url>%2F2017%2F07%2F22%2Fubuntu-Reduce-the-version-gcc-g%2B%2B%2F</url>
    <content type="text"><![CDATA[有时候我们在跑别人的程序的时候发现自己编译器的版本过高以至于不能运行，这个时候我们就需要降低编译器的版本。 首先安装低版本的编译器这里由于本人用的ubuntu16.04所以编译器自带的是gcc-5.4和g++-5.4,但是需要低版本的，经过测试现在还可以安装4.7的版本 sudo apt-get install gcc-4.7 gcc-4.7-multilib g++-4.7 g++-4.7-multilib 配置级别sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.7 50 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 40 接着输入 sudo update-alternatives --config gcc 然后可以自己选择版本。 同理配置好了gcc还要配置g++ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.7 50 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40 同理g++的选择为： sudo update-alternatives --config g++ 如果想删除可选项的话可以键入以下指令： sudo update-alternatives --remove gcc /usr/bin/gcc-4.5 本文是自己跟同门根据网上资料整理而得，希望对大家有用。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04 Server install CUDA]]></title>
    <url>%2F2017%2F07%2F22%2Fubuntu16-04-Server-install-CUDA%2F</url>
    <content type="text"><![CDATA[ubuntu16.04 Server 安装CUDA在安装CUDA的时候经常会遇到CUDA安装失败的情况，一般遇到的不允许第三方软件的安装，或者是自带的驱动nouveau的存在。 允许第三方软件的安装这个需要自己重启电脑进入bios系统中去关闭UEFI的安全启动/安全引导 关闭自带的驱动nouveausudo vim /etc/modprobe.d/blacklist.conf 在该文件中添加以下几行： blacklist vga16fb blacklist rivafb blacklist rivatv blacklist nvidiafb options nouveau modeset=0 添加完以后保存该文件接着更新该文件，使配置有用 sudo update-initramfs -u 最后查看nouveau驱动禁止是否成功，如果没有内容则说明禁用成功。 如果nouveau驱动禁用后没有效果，可以进行强制移除该驱动（如果上面的方法禁用成功可以不使用该方法）将这个驱动备份出来然后移除 mv /lib/modules/3.0.0-12-generic/kernel/drivers/gpu/drm/nouveau/nouveau.ko /lib/modules/3.0.0-12-generic/kernel/drivers/gpu/drm/nouveau/nouveau.ko.org 重新加载 update-initramfs -u 重启发现字体已经变大了，卸载成功。 CUDA的安装因为本文说的ubuntu Server所以安装完一般使没有图形界面的，所以不需要去禁用图形界面，如果不是server版本的话一般还需要禁用图形界面的（可以用ctrl+alt+F1进入文本界面，F1~F6都可以F7是退出文本界面）。禁用图形界面的语句： sudo service lightdm stop 打开图形界面的语句： sudo service lightdm start nouveau禁用成功了，bios中的UEFI也已经关了，这个时候就可以安心的装CUDA了。首先需要安装依赖项： sudo apt-get install build-essential pkg-config linux-headers-$(uname -r) 或者下面的方法也可以（用了上面的语句下面的语句就不需要了）： sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler sudo apt-get install --no-install-recommends libboost-all-dev sudo apt-get install libopenblas-dev liblapack-dev libatlas-base-dev sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev 下载CUDA的安装包https://developer.nvidia.com/cuda-downloads可以去NVIDIA的官网去下载，可以根据需求下载。本文下载的runfile，其他形式的文本运行方法在下载界面有介绍的。下载好后用U盘或者SCP等上传到服务器上，接下来进入cuda安装包的地方执行，当然这里根据你的安装包的型号。 sudo sh cuda_8.0.61_375.26_linux.run 执行以后会有一堆文本让你读，很多，不过可以直接按q退出，然后按照要求先accept，然后再按照自己的需求安装，因为上面没有手动安装过nvidia的驱动，所以这里需要选择安装驱动的，否则cuda即使安装上了也没有用的。选择完了就开始安装了，安装完成后会有一个Summary显示安装的情况的。到此基本安装完了，可以使用下面的语句去检测nvidia驱动是否安装成功： cat /proc/driver/nvidia/version 如果可以弹出来驱动的版本信息等，说明安装成功，否者没有安装成功。 安装完后此时查找cuda是找不到的，因为还没有配置环境变量。接下来配置环境变量： echo &#39;export PATH=/usr/local/cuda/bin:$PATH&#39; &gt;&gt; ~/.bashrc echo &#39;export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH&#39; &gt;&gt; ~/.bashrc source ~/.bashrc 配置完环境变量后再检查一下cuda是否安装成功 nvcc -V 提示上面的必须是大写的V，小写的v是不能够被识别的。 如果要卸载或者重装卸载或者重新安装了。这个时候需要先卸载之前安装的。这个在用run文件安装的时候，最后那个summary已经告诉我们如何卸载了。 To uninstall the CUDA Toolkit. run the uninstall scrip in /usr/local/cuda-8.0/bin To uninstall the NVIDIA Driver. run nvidia-unistall 可以先按照上面的提示去卸载CUDA和NVIDIA驱动，当然还有其他的方法 sudo apt-get --purge remove &lt;package_name&gt; 本文参考网络上各种资源自己配置完自己实验室电脑后整理所得，做一个备忘所用，当然也希望对大家有用。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thanks]]></title>
    <url>%2F2017%2F07%2F22%2Fthanks%2F</url>
    <content type="text"><![CDATA[Thanks for JingJing’s help to me!]]></content>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
